Disassembly Listing for FrqMeter32Bits
Generated From:
C:/microchip/harmony/v2_05_01/apps/MINF/Epreuves/TE_FrqMtr32Bits/firmware/FrqMeter32Bits.X/dist/default/production/FrqMeter32Bits.X.production.elf
14 févr. 2019 11:26:06

---  c:/microchip/harmony/v2_05_01/framework/system/int/src/sys_int_pic32.c  ----------------------------
1:                   /*******************************************************************************
2:                     Interrupt System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_int_pic32.c
9:                   
10:                    Summary:
11:                      Interrupt System Service APIs.
12:                  
13:                    Description:
14:                      This file contains functions related to the Interrupt System Service for PIC32
15:                      devices.
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  #include "system/int/sys_int.h"
44:                  
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  // Section: Function Definitions
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  
51:                  
52:                  /******************************************************************************
53:                  
54:                    Function:
55:                      void SYS_INT_Initialize ( void )
56:                  
57:                    Summary:
58:                      Configures and initializes the interrupt sub-system.
59:                  
60:                    Description:
61:                      This function appropriately configures and initializes the interrupt sub-system
62:                      for the current system design.
63:                  
64:                    Precondition:
65:                      None.
66:                  
67:                    Parameters:
68:                      None.
69:                  
70:                    Returns:
71:                      None.
72:                  
73:                    Example:
74:                    <code>
75:                    SYS_INT_Initialize();
76:                    </code>
77:                  
78:                    Remarks:
79:                      This function is not implemented in the System Interrupt library.  It is
80:                      implemented by the board support package (using the processor-specific
81:                      interrupt peripheral library) because it requires knowledge of the specific
82:                      interrupt requirements for each system.
83:                  */
84:                  
85:                  void SYS_INT_Initialize ( void )
86:                  
87:                  {
9D006AA0  27BDFFE8   ADDIU SP, SP, -24
9D006AA4  AFBF0014   SW RA, 20(SP)
9D006AA8  AFBE0010   SW FP, 16(SP)
9D006AAC  03A0F021   ADDU FP, SP, ZERO
88:                      /* enable the multi vector */
89:                      PLIB_INT_MultiVectorSelect( INT_ID_0 );
9D006AB0  00002021   ADDU A0, ZERO, ZERO
9D006AB4  0F401BA0   JAL PLIB_INT_MultiVectorSelect
9D006AB8  00000000   NOP
90:                  }
9D006ABC  03C0E821   ADDU SP, FP, ZERO
91:                  
92:                  //*******************************************************************************
93:                  /*  Function:
94:                       SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
95:                  
96:                    Summary:
97:                      Disables interrupts to the processor and return the previois status.
98:                      
99:                    Description:
100:                     This function disables interrupts to the processor at the top level. This
101:                     function can be called to prevent any source from being able to generate an
102:                     interrupt. It returns the processor status (which includes global interrupt
103:                     status and Interrupt Priority status) before disabling the interrupts.
104:                 
105:                   Remarks:
106:                     See sys_int.h file for more details.
107:                 */
108:                 
109:                 SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
110:                 {
111:                     SYS_INT_PROCESSOR_STATUS processorStatus;
112:                 
113:                     /* Save the processor status and then Disable the global interrupt */
114:                     processorStatus = ( SYS_INT_PROCESSOR_STATUS )__builtin_disable_interrupts();
115:                 
116:                     /* return the processor status */
117:                     return processorStatus;
118:                 }
119:                 
120:                 //*******************************************************************************
121:                 /* Function:
122:                     void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
123:                 
124:                   Summary:
125:                     Restores the processor status.
126:                 
127:                   Description:
128:                     This function sets the processor status based on the 32 bit value passed as 
129:                     a parameter. 0th bit of the status is for Master Interrupt status.
130:                 
131:                   Remarks:
132:                     See sys_int.h file for more details.
133:                 */
134:                 
135:                 void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
136:                 {
137:                     __builtin_mtc0(12, 0, processorStatus);
138:                 }
139:                 
140:                 // *****************************************************************************
141:                 /*  Disable the generation of interrupts to the CPU
142:                 
143:                   Summary:
144:                      Disables all interrupts
145:                 
146:                   Description:
147:                      This function disables all interrupts.
148:                 
149:                   Remarks:
150:                     This API will be depricated soon. Use "SYS_INT_StatusGetAndDisable" instead.
151:                  */
152:                 
153:                 bool SYS_INT_Disable( void )
154:                 {
155:                     SYS_INT_PROCESSOR_STATUS processorStatus;
156:                 
157:                     /* Save the processor status and then Disable the global interrupt */
158:                     processorStatus = ( SYS_INT_PROCESSOR_STATUS )__builtin_disable_interrupts();
159:                 
160:                     /* return the interrupt status */
161:                     return (bool)(processorStatus & 0x01);
162:                 }
163:                 
164:                 // *****************************************************************************
165:                 /* Function:
166:                     bool SYS_INT_SourceDisable ( INT_SOURCE source )
167:                 
168:                   Summary:
169:                     Disables the interrupt source.
170:                 
171:                   Description:
172:                     This routine disables the given source from generating interrupts the 
173:                     processor when events occur.It returns the interrupt source enable/disable 
174:                 	status before disabling the interrupt source.
175:                 
176:                   Remarks:
177:                     See sys_int.h file for more details.
178:                  */
179:                 
180:                 
181:                 bool SYS_INT_SourceDisable ( INT_SOURCE source )
182:                 {
183:                     bool intSrcStatus;
184:                     SYS_INT_PROCESSOR_STATUS processorStatus;
185:                 
186:                     /* Save the processor status and then Disable the global interrupt */
187:                     processorStatus = ( SYS_INT_PROCESSOR_STATUS )__builtin_disable_interrupts();
188:                     
189:                     /* get the interrupt status of this source before disable is called */
190:                     intSrcStatus = PLIB_INT_SourceIsEnabled (INT_ID_0 , source);
191:                 
192:                     /* disable the interrupts */
193:                     PLIB_INT_SourceDisable (INT_ID_0 , source);
194:                 
195:                     /* restore the state of CP0 Status register before the disable occurred*/
196:                     __builtin_mtc0(12, 0, processorStatus);
197:                 
198:                     /* return the source status */
199:                     return intSrcStatus;
200:                 }
201:                 
202:                 
203:                 // *****************************************************************************
204:                 /* Sets the external interrupt trigger type.
205:                 
206:                   Summary:
207:                     Sets the external interrupt trigger type.
208:                 
209:                   Description:
210:                     This function sets the External interrupt trigger type.
211:                 
212:                   Remarks:
213:                     Refer the datasheet to know the external interrupt sources supported.
214:                  */
215:                 
216:                 void SYS_INT_ExternalInterruptTriggerSet ( 	INT_EXTERNAL_SOURCES source,
217:                 										INT_EXTERNAL_EDGE_TRIGGER edgeTrigger )
218:                 {
219:                 	if ( edgeTrigger == INT_EDGE_TRIGGER_RISING )
220:                 	{
221:                 		PLIB_INT_ExternalRisingEdgeSelect ( INT_ID_0, source );
222:                 	}
223:                 	else
224:                 	{
225:                 		PLIB_INT_ExternalFallingEdgeSelect ( INT_ID_0, source );
226:                 	}
227:                 }
228:                 
---  c:/microchip/harmony/v2_05_01/bsp/pic32mx_skes/mc32driverlcd.c  ------------------------------------
1:                   /*--------------------------------------------------------*/
2:                   //      Mc32DriverLcd.c
3:                   /*--------------------------------------------------------*/
4:                   //	Description :	Driver pour LCD PIC 32
5:                   //
6:                   //
7:                   //	Auteur 		: 	Gomes Andres
8:                   //
9:                   //	Version		:	V1.2
10:                  //	Compilateur	:	XC32 V1.33 & harmony 1.00
11:                  //
12:                  //      MODIFICATIONS   :
13:                  //          CHR 15.05.2014   retouche lcd_putc
14:                  //          CHR 15.05.2014   ajout lcd_printf
15:                  //          CHR 09.09.2014   utilisation de bsp_cponfig.h
16:                  //          SCA 11.10.2016   utilisation des délais core timer
17:                  //
18:                  /*--------------------------------------------------------*/
19:                  
20:                  
21:                  #include "GenericTypeDefs.h"
22:                  #include "bsp.h"
23:                  #include "Mc32DriverLcd.h"
24:                  #include "Mc32Delays.h"
25:                  
26:                  /*--------------------------------------------------------*/
27:                  // Définition du tableau pour l'adresse des lignes
28:                  /*--------------------------------------------------------*/
29:                  const BYTE taddrLines[5] = { 0,    // ligne 0 pas utilisé
30:                                               0,    // ligne 1 commence au caractère 0
31:                                               64,    // ligne 2 commence au caractère 64 (0x40)
32:                                               20,    // ligne 3 commence au caractère 20
33:                                               84 };  // ligne 4 commence au caractère 84 (0x40+20)
34:                  /*--------------------------------------------------------*/
35:                  // Fonctions
36:                  /*--------------------------------------------------------*/
37:                  BYTE lcd_read_byte( void )
38:                  {
9D003CEC  27BDFFE0   ADDIU SP, SP, -32
9D003CF0  AFBF001C   SW RA, 28(SP)
9D003CF4  AFBE0018   SW FP, 24(SP)
9D003CF8  03A0F021   ADDU FP, SP, ZERO
39:                        UINT8_BITS lcd_read_byte;
40:                  	  LCD_DB4_T = 1; // 1=input
9D003CFC  3C03BF88   LUI V1, -16504
9D003D00  94626100   LHU V0, 24832(V1)
9D003D04  24040001   ADDIU A0, ZERO, 1
9D003D08  7C822104   INS V0, A0, 4, 1
9D003D0C  A4626100   SH V0, 24832(V1)
41:                     	  LCD_DB5_T = 1;
9D003D10  3C03BF88   LUI V1, -16504
9D003D14  94626100   LHU V0, 24832(V1)
9D003D18  24040001   ADDIU A0, ZERO, 1
9D003D1C  7C822944   INS V0, A0, 5, 1
9D003D20  A4626100   SH V0, 24832(V1)
42:                  	  LCD_DB6_T = 1;
9D003D24  3C03BF88   LUI V1, -16504
9D003D28  94626100   LHU V0, 24832(V1)
9D003D2C  24040001   ADDIU A0, ZERO, 1
9D003D30  7C823184   INS V0, A0, 6, 1
9D003D34  A4626100   SH V0, 24832(V1)
43:                  	  LCD_DB7_T = 1;
9D003D38  3C03BF88   LUI V1, -16504
9D003D3C  94626100   LHU V0, 24832(V1)
9D003D40  24040001   ADDIU A0, ZERO, 1
9D003D44  7C8239C4   INS V0, A0, 7, 1
9D003D48  A4626100   SH V0, 24832(V1)
44:                        LCD_RW_W = 1;
9D003D4C  3C03BF88   LUI V1, -16504
9D003D50  94626120   LHU V0, 24864(V1)
9D003D54  24040001   ADDIU A0, ZERO, 1
9D003D58  7C820844   INS V0, A0, 1, 1
9D003D5C  A4626120   SH V0, 24864(V1)
45:                  	  delay500nsCt(); //ds0066 demande 0.5us
9D003D60  0F401A10   JAL delay500nsCt
9D003D64  00000000   NOP
46:                        LCD_E_W = 1;
9D003D68  3C03BF88   LUI V1, -16504
9D003D6C  94626120   LHU V0, 24864(V1)
9D003D70  24040001   ADDIU A0, ZERO, 1
9D003D74  7C821084   INS V0, A0, 2, 1
9D003D78  A4626120   SH V0, 24864(V1)
47:                  	  delay500nsCt(); //ds0066 demande 0.5us
9D003D7C  0F401A10   JAL delay500nsCt
9D003D80  00000000   NOP
48:                        lcd_read_byte.bits.b7 = LCD_DB7_R;
9D003D84  3C02BF88   LUI V0, -16504
9D003D88  8C426110   LW V0, 24848(V0)
9D003D8C  7C4201C0   EXT V0, V0, 7, 1
9D003D90  304300FF   ANDI V1, V0, 255
9D003D94  93C20010   LBU V0, 16(FP)
9D003D98  7C6239C4   INS V0, V1, 7, 1
9D003D9C  A3C20010   SB V0, 16(FP)
49:                        lcd_read_byte.bits.b6 = LCD_DB6_R;
9D003DA0  3C02BF88   LUI V0, -16504
9D003DA4  8C426110   LW V0, 24848(V0)
9D003DA8  7C420180   EXT V0, V0, 6, 1
9D003DAC  304300FF   ANDI V1, V0, 255
9D003DB0  93C20010   LBU V0, 16(FP)
9D003DB4  7C623184   INS V0, V1, 6, 1
9D003DB8  A3C20010   SB V0, 16(FP)
50:                        lcd_read_byte.bits.b5 = LCD_DB5_R;
9D003DBC  3C02BF88   LUI V0, -16504
9D003DC0  8C426110   LW V0, 24848(V0)
9D003DC4  7C420140   EXT V0, V0, 5, 1
9D003DC8  304300FF   ANDI V1, V0, 255
9D003DCC  93C20010   LBU V0, 16(FP)
9D003DD0  7C622944   INS V0, V1, 5, 1
9D003DD4  A3C20010   SB V0, 16(FP)
51:                        lcd_read_byte.bits.b4 = LCD_DB4_R;
9D003DD8  3C02BF88   LUI V0, -16504
9D003DDC  8C426110   LW V0, 24848(V0)
9D003DE0  7C420100   EXT V0, V0, 4, 1
9D003DE4  304300FF   ANDI V1, V0, 255
9D003DE8  93C20010   LBU V0, 16(FP)
9D003DEC  7C622104   INS V0, V1, 4, 1
9D003DF0  A3C20010   SB V0, 16(FP)
52:                        LCD_E_W = 0; // attention e pulse min = 500ns à 1 et autant à 0
9D003DF4  3C03BF88   LUI V1, -16504
9D003DF8  94626120   LHU V0, 24864(V1)
9D003DFC  7C021084   INS V0, ZERO, 2, 1
9D003E00  A4626120   SH V0, 24864(V1)
53:                  	  delay500nsCt();
9D003E04  0F401A10   JAL delay500nsCt
9D003E08  00000000   NOP
54:                        LCD_E_W = 1;
9D003E0C  3C03BF88   LUI V1, -16504
9D003E10  94626120   LHU V0, 24864(V1)
9D003E14  24040001   ADDIU A0, ZERO, 1
9D003E18  7C821084   INS V0, A0, 2, 1
9D003E1C  A4626120   SH V0, 24864(V1)
55:                        delay500nsCt();
9D003E20  0F401A10   JAL delay500nsCt
9D003E24  00000000   NOP
56:                        lcd_read_byte.bits.b3 = LCD_DB7_R;
9D003E28  3C02BF88   LUI V0, -16504
9D003E2C  8C426110   LW V0, 24848(V0)
9D003E30  7C4201C0   EXT V0, V0, 7, 1
9D003E34  304300FF   ANDI V1, V0, 255
9D003E38  93C20010   LBU V0, 16(FP)
9D003E3C  7C6218C4   INS V0, V1, 3, 1
9D003E40  A3C20010   SB V0, 16(FP)
57:                        lcd_read_byte.bits.b2 = LCD_DB6_R;
9D003E44  3C02BF88   LUI V0, -16504
9D003E48  8C426110   LW V0, 24848(V0)
9D003E4C  7C420180   EXT V0, V0, 6, 1
9D003E50  304300FF   ANDI V1, V0, 255
9D003E54  93C20010   LBU V0, 16(FP)
9D003E58  7C621084   INS V0, V1, 2, 1
9D003E5C  A3C20010   SB V0, 16(FP)
58:                        lcd_read_byte.bits.b1 = LCD_DB5_R;
9D003E60  3C02BF88   LUI V0, -16504
9D003E64  8C426110   LW V0, 24848(V0)
9D003E68  7C420140   EXT V0, V0, 5, 1
9D003E6C  304300FF   ANDI V1, V0, 255
9D003E70  93C20010   LBU V0, 16(FP)
9D003E74  7C620844   INS V0, V1, 1, 1
9D003E78  A3C20010   SB V0, 16(FP)
59:                        lcd_read_byte.bits.b0 = LCD_DB4_R;
9D003E7C  3C02BF88   LUI V0, -16504
9D003E80  8C426110   LW V0, 24848(V0)
9D003E84  7C420100   EXT V0, V0, 4, 1
9D003E88  304300FF   ANDI V1, V0, 255
9D003E8C  93C20010   LBU V0, 16(FP)
9D003E90  7C620004   INS V0, V1, 0, 1
9D003E94  A3C20010   SB V0, 16(FP)
60:                        LCD_E_W = 0;
9D003E98  3C03BF88   LUI V1, -16504
9D003E9C  94626120   LHU V0, 24864(V1)
9D003EA0  7C021084   INS V0, ZERO, 2, 1
9D003EA4  A4626120   SH V0, 24864(V1)
61:                        delay500nsCt();
9D003EA8  0F401A10   JAL delay500nsCt
9D003EAC  00000000   NOP
62:                        LCD_DB4_T = 0; // 0=output
9D003EB0  3C03BF88   LUI V1, -16504
9D003EB4  94626100   LHU V0, 24832(V1)
9D003EB8  7C022104   INS V0, ZERO, 4, 1
9D003EBC  A4626100   SH V0, 24832(V1)
63:                  	  LCD_DB5_T = 0;
9D003EC0  3C03BF88   LUI V1, -16504
9D003EC4  94626100   LHU V0, 24832(V1)
9D003EC8  7C022944   INS V0, ZERO, 5, 1
9D003ECC  A4626100   SH V0, 24832(V1)
64:                  	  LCD_DB6_T = 0;
9D003ED0  3C03BF88   LUI V1, -16504
9D003ED4  94626100   LHU V0, 24832(V1)
9D003ED8  7C023184   INS V0, ZERO, 6, 1
9D003EDC  A4626100   SH V0, 24832(V1)
65:                  	  LCD_DB7_T = 0;
9D003EE0  3C03BF88   LUI V1, -16504
9D003EE4  94626100   LHU V0, 24832(V1)
9D003EE8  7C0239C4   INS V0, ZERO, 7, 1
9D003EEC  A4626100   SH V0, 24832(V1)
66:                        return(lcd_read_byte.Val);
9D003EF0  93C20010   LBU V0, 16(FP)
67:                  }
9D003EF4  03C0E821   ADDU SP, FP, ZERO
68:                  
69:                  /*--------------------------------------------------------*/
70:                  void lcd_send_nibble( BYTE n )
71:                  {
9D005230  27BDFFE0   ADDIU SP, SP, -32
9D005234  AFBF001C   SW RA, 28(SP)
9D005238  AFBE0018   SW FP, 24(SP)
9D00523C  03A0F021   ADDU FP, SP, ZERO
9D005240  00801021   ADDU V0, A0, ZERO
9D005244  A3C20020   SB V0, 32(FP)
72:                     UINT8_BITS NibbleToWrite;
73:                     NibbleToWrite.Val = n;
9D005248  93C20020   LBU V0, 32(FP)
9D00524C  A3C20010   SB V0, 16(FP)
74:                     LCD_DB7_W = NibbleToWrite.bits.b3;
9D005250  8FC20010   LW V0, 16(FP)
9D005254  7C4200C0   EXT V0, V0, 3, 1
9D005258  304400FF   ANDI A0, V0, 255
9D00525C  3C03BF88   LUI V1, -16504
9D005260  94626120   LHU V0, 24864(V1)
9D005264  7C8239C4   INS V0, A0, 7, 1
9D005268  A4626120   SH V0, 24864(V1)
75:                     LCD_DB6_W = NibbleToWrite.bits.b2;
9D00526C  8FC20010   LW V0, 16(FP)
9D005270  7C420080   EXT V0, V0, 2, 1
9D005274  304400FF   ANDI A0, V0, 255
9D005278  3C03BF88   LUI V1, -16504
9D00527C  94626120   LHU V0, 24864(V1)
9D005280  7C823184   INS V0, A0, 6, 1
9D005284  A4626120   SH V0, 24864(V1)
76:                     LCD_DB5_W = NibbleToWrite.bits.b1;
9D005288  8FC20010   LW V0, 16(FP)
9D00528C  7C420040   EXT V0, V0, 1, 1
9D005290  304400FF   ANDI A0, V0, 255
9D005294  3C03BF88   LUI V1, -16504
9D005298  94626120   LHU V0, 24864(V1)
9D00529C  7C822944   INS V0, A0, 5, 1
9D0052A0  A4626120   SH V0, 24864(V1)
77:                     LCD_DB4_W = NibbleToWrite.bits.b0;
9D0052A4  8FC20010   LW V0, 16(FP)
9D0052A8  7C420000   EXT V0, V0, 0, 1
9D0052AC  304400FF   ANDI A0, V0, 255
9D0052B0  3C03BF88   LUI V1, -16504
9D0052B4  94626120   LHU V0, 24864(V1)
9D0052B8  7C822104   INS V0, A0, 4, 1
9D0052BC  A4626120   SH V0, 24864(V1)
78:                     delay500nsCt();
9D0052C0  0F401A10   JAL delay500nsCt
9D0052C4  00000000   NOP
79:                     LCD_E_W = 1;
9D0052C8  3C03BF88   LUI V1, -16504
9D0052CC  94626120   LHU V0, 24864(V1)
9D0052D0  24040001   ADDIU A0, ZERO, 1
9D0052D4  7C821084   INS V0, A0, 2, 1
9D0052D8  A4626120   SH V0, 24864(V1)
80:                     delay500nsCt(); // E pulse width min = 450ns pour le 1!
9D0052DC  0F401A10   JAL delay500nsCt
9D0052E0  00000000   NOP
81:                     LCD_E_W = 0;
9D0052E4  3C03BF88   LUI V1, -16504
9D0052E8  94626120   LHU V0, 24864(V1)
9D0052EC  7C021084   INS V0, ZERO, 2, 1
9D0052F0  A4626120   SH V0, 24864(V1)
82:                     delay500nsCt(); // E pulse width min = 450ns également pour le 0!
9D0052F4  0F401A10   JAL delay500nsCt
9D0052F8  00000000   NOP
83:                  }
9D0052FC  03C0E821   ADDU SP, FP, ZERO
84:                  
85:                  /*--------------------------------------------------------*/
86:                  void lcd_send_byte( BYTE address, BYTE n )
87:                  {
9D005724  27BDFFE8   ADDIU SP, SP, -24
9D005728  AFBF0014   SW RA, 20(SP)
9D00572C  AFBE0010   SW FP, 16(SP)
9D005730  03A0F021   ADDU FP, SP, ZERO
9D005734  00801821   ADDU V1, A0, ZERO
9D005738  00A01021   ADDU V0, A1, ZERO
9D00573C  A3C30018   SB V1, 24(FP)
9D005740  A3C2001C   SB V0, 28(FP)
88:                  	LCD_RS_W = 0;
9D005744  3C03BF88   LUI V1, -16504
9D005748  94626120   LHU V0, 24864(V1)
9D00574C  7C020004   INS V0, ZERO, 0, 1
9D005750  A4626120   SH V0, 24864(V1)
89:                  	while ( (lcd_read_byte() & 0x80) == 0x80 ) ;
9D005754  00000000   NOP
9D005758  0F400F3B   JAL lcd_read_byte
9D00575C  00000000   NOP
9D005760  7C021420   SEB V0, V0
9D005764  0440FFFC   BLTZ V0, 0x9D005758
9D005768  00000000   NOP
90:                      LCD_RS_W = address;
9D00576C  93C20018   LBU V0, 24(FP)
9D005770  30420001   ANDI V0, V0, 1
9D005774  304400FF   ANDI A0, V0, 255
9D005778  3C03BF88   LUI V1, -16504
9D00577C  94626120   LHU V0, 24864(V1)
9D005780  7C820004   INS V0, A0, 0, 1
9D005784  A4626120   SH V0, 24864(V1)
91:                      LCD_RW_W = 0;
9D005788  3C03BF88   LUI V1, -16504
9D00578C  94626120   LHU V0, 24864(V1)
9D005790  7C020844   INS V0, ZERO, 1, 1
9D005794  A4626120   SH V0, 24864(V1)
92:                      //LCD_E déjà à 0
93:                      lcd_send_nibble(n >> 4);
9D005798  93C2001C   LBU V0, 28(FP)
9D00579C  00021102   SRL V0, V0, 4
9D0057A0  304200FF   ANDI V0, V0, 255
9D0057A4  00402021   ADDU A0, V0, ZERO
9D0057A8  0F40148C   JAL lcd_send_nibble
9D0057AC  00000000   NOP
94:                      lcd_send_nibble(n & 0xf);
9D0057B0  93C2001C   LBU V0, 28(FP)
9D0057B4  3042000F   ANDI V0, V0, 15
9D0057B8  304200FF   ANDI V0, V0, 255
9D0057BC  00402021   ADDU A0, V0, ZERO
9D0057C0  0F40148C   JAL lcd_send_nibble
9D0057C4  00000000   NOP
95:                  }
9D0057C8  03C0E821   ADDU SP, FP, ZERO
96:                  
97:                  /*--------------------------------------------------------*/
98:                  void lcd_init(void)
99:                  {
9D004BBC  27BDFFE8   ADDIU SP, SP, -24
9D004BC0  AFBF0014   SW RA, 20(SP)
9D004BC4  AFBE0010   SW FP, 16(SP)
9D004BC8  03A0F021   ADDU FP, SP, ZERO
100:                   // on va effectuer exactement ce que demande le ks0066
101:                   // on repositionne LCD_E tout pour un démarrage correct
102:                     LCD_E_W = 0;
9D004BCC  3C03BF88   LUI V1, -16504
9D004BD0  94626120   LHU V0, 24864(V1)
9D004BD4  7C021084   INS V0, ZERO, 2, 1
9D004BD8  A4626120   SH V0, 24864(V1)
103:                     delay_usCt(1); // si LCD_E était à 1, on attend
9D004BDC  24040001   ADDIU A0, ZERO, 1
9D004BE0  0F4018A6   JAL delay_usCt
9D004BE4  00000000   NOP
104:                     LCD_RS_W = 0;  // demandé pour une commande
9D004BE8  3C03BF88   LUI V1, -16504
9D004BEC  94626120   LHU V0, 24864(V1)
9D004BF0  7C020004   INS V0, ZERO, 0, 1
9D004BF4  A4626120   SH V0, 24864(V1)
105:                     LCD_RW_W = 0;
9D004BF8  3C03BF88   LUI V1, -16504
9D004BFC  94626120   LHU V0, 24864(V1)
9D004C00  7C020844   INS V0, ZERO, 1, 1
9D004C04  A4626120   SH V0, 24864(V1)
106:                     // suivant comment l'interfaçage avec le LCD s'est arrêté, il faut tout remettre à plat
107:                     // selon les notes d'applications, il faut envoyer 3 fois un nibble 0x3
108:                     // pour lui faire croire que nous sommes en interface8 bits
109:                     // chaque envoi doit être séparé de 5ms!!
110:                     lcd_send_nibble(0x03); // correspond à 0x30, interface 8 bits
9D004C08  24040003   ADDIU A0, ZERO, 3
9D004C0C  0F40148C   JAL lcd_send_nibble
9D004C10  00000000   NOP
111:                     delay_msCt(5);
9D004C14  24040005   ADDIU A0, ZERO, 5
9D004C18  0F4017DB   JAL delay_msCt
9D004C1C  00000000   NOP
112:                     lcd_send_nibble(0x03); // correspond à 0x30, interface 8 bits
9D004C20  24040003   ADDIU A0, ZERO, 3
9D004C24  0F40148C   JAL lcd_send_nibble
9D004C28  00000000   NOP
113:                     delay_msCt(5);
9D004C2C  24040005   ADDIU A0, ZERO, 5
9D004C30  0F4017DB   JAL delay_msCt
9D004C34  00000000   NOP
114:                     lcd_send_nibble(0x03); // correspond à 0x30, interface 8 bits
9D004C38  24040003   ADDIU A0, ZERO, 3
9D004C3C  0F40148C   JAL lcd_send_nibble
9D004C40  00000000   NOP
115:                     delay_msCt(5);
9D004C44  24040005   ADDIU A0, ZERO, 5
9D004C48  0F4017DB   JAL delay_msCt
9D004C4C  00000000   NOP
116:                     // maintenant, on peut configurer notre LCD en interface 4 bits
117:                     LCD_RS_W = 0;  // demandé pour une commande (on assure!)
9D004C50  3C03BF88   LUI V1, -16504
9D004C54  94626120   LHU V0, 24864(V1)
9D004C58  7C020004   INS V0, ZERO, 0, 1
9D004C5C  A4626120   SH V0, 24864(V1)
118:                     lcd_send_nibble(2);// 4 bits interface
9D004C60  24040002   ADDIU A0, ZERO, 2
9D004C64  0F40148C   JAL lcd_send_nibble
9D004C68  00000000   NOP
119:                     lcd_send_byte(0,0b00101000); //rs=0, 2 lines mode, display off
9D004C6C  00002021   ADDU A0, ZERO, ZERO
9D004C70  24050028   ADDIU A1, ZERO, 40
9D004C74  0F4015C9   JAL lcd_send_byte
9D004C78  00000000   NOP
120:                     delay_usCt(40); //ds0066 demande >39us
9D004C7C  24040028   ADDIU A0, ZERO, 40
9D004C80  0F4018A6   JAL delay_usCt
9D004C84  00000000   NOP
121:                     lcd_send_byte(0,0b00001100); //rs=0, display on, cursor off, blink off
9D004C88  00002021   ADDU A0, ZERO, ZERO
9D004C8C  2405000C   ADDIU A1, ZERO, 12
9D004C90  0F4015C9   JAL lcd_send_byte
9D004C94  00000000   NOP
122:                     delay_usCt(40); //ds0066 demande >39us
9D004C98  24040028   ADDIU A0, ZERO, 40
9D004C9C  0F4018A6   JAL delay_usCt
9D004CA0  00000000   NOP
123:                     lcd_send_byte(0,0b00000001); //rs=0, display clear
9D004CA4  00002021   ADDU A0, ZERO, ZERO
9D004CA8  24050001   ADDIU A1, ZERO, 1
9D004CAC  0F4015C9   JAL lcd_send_byte
9D004CB0  00000000   NOP
124:                     delay_msCt(2); //ds0066 demande >1,53ms
9D004CB4  24040002   ADDIU A0, ZERO, 2
9D004CB8  0F4017DB   JAL delay_msCt
9D004CBC  00000000   NOP
125:                     lcd_send_byte(0,0b00000110); //rs=0, increment mode, entire shift off
9D004CC0  00002021   ADDU A0, ZERO, ZERO
9D004CC4  24050006   ADDIU A1, ZERO, 6
9D004CC8  0F4015C9   JAL lcd_send_byte
9D004CCC  00000000   NOP
126:                     delay_usCt(40); //ds0066 demande >39us
9D004CD0  24040028   ADDIU A0, ZERO, 40
9D004CD4  0F4018A6   JAL delay_usCt
9D004CD8  00000000   NOP
127:                 }
9D004CDC  03C0E821   ADDU SP, FP, ZERO
128:                 
129:                 /*--------------------------------------------------------*/
130:                 void lcd_gotoxy( BYTE x, BYTE y)
131:                 {
9D005EE4  27BDFFE0   ADDIU SP, SP, -32
9D005EE8  AFBF001C   SW RA, 28(SP)
9D005EEC  AFBE0018   SW FP, 24(SP)
9D005EF0  03A0F021   ADDU FP, SP, ZERO
9D005EF4  00801821   ADDU V1, A0, ZERO
9D005EF8  00A01021   ADDU V0, A1, ZERO
9D005EFC  A3C30020   SB V1, 32(FP)
9D005F00  A3C20024   SB V0, 36(FP)
132:                    BYTE address;
133:                    address = taddrLines[y];
9D005F04  93C30024   LBU V1, 36(FP)
9D005F08  3C029D00   LUI V0, -25344
9D005F0C  24426F68   ADDIU V0, V0, 28520
9D005F10  00621021   ADDU V0, V1, V0
9D005F14  90420000   LBU V0, 0(V0)
9D005F18  A3C20010   SB V0, 16(FP)
134:                    address+=x-1;
9D005F1C  93C30020   LBU V1, 32(FP)
9D005F20  93C20010   LBU V0, 16(FP)
9D005F24  00621021   ADDU V0, V1, V0
9D005F28  304200FF   ANDI V0, V0, 255
9D005F2C  2442FFFF   ADDIU V0, V0, -1
9D005F30  A3C20010   SB V0, 16(FP)
135:                    lcd_send_byte(0,0x80|address);
9D005F34  93C30010   LBU V1, 16(FP)
9D005F38  2402FF80   ADDIU V0, ZERO, -128
9D005F3C  00621025   OR V0, V1, V0
9D005F40  304200FF   ANDI V0, V0, 255
9D005F44  00002021   ADDU A0, ZERO, ZERO
9D005F48  00402821   ADDU A1, V0, ZERO
9D005F4C  0F4015C9   JAL lcd_send_byte
9D005F50  00000000   NOP
136:                 }
9D005F54  03C0E821   ADDU SP, FP, ZERO
137:                 
138:                 /*--------------------------------------------------------*/
139:                 // Modif du 15.05.2014 C. Huber
140:                 void lcd_putc( BYTE c)
141:                 {
9D005664  27BDFFE8   ADDIU SP, SP, -24
9D005668  AFBF0014   SW RA, 20(SP)
9D00566C  AFBE0010   SW FP, 16(SP)
9D005670  03A0F021   ADDU FP, SP, ZERO
9D005674  00801021   ADDU V0, A0, ZERO
9D005678  A3C20018   SB V0, 24(FP)
142:                 	switch (c)
9D00567C  93C20018   LBU V0, 24(FP)
9D005680  2403000A   ADDIU V1, ZERO, 10
9D005684  1043000F   BEQ V0, V1, 0x9D0056C4
9D005688  00000000   NOP
9D00568C  2403000C   ADDIU V1, ZERO, 12
9D005690  10430006   BEQ V0, V1, 0x9D0056AC
9D005694  00000000   NOP
9D005698  24030008   ADDIU V1, ZERO, 8
9D00569C  1043000F   BEQ V0, V1, 0x9D0056DC
9D0056A0  00000000   NOP
9D0056A4  0B4015BD   J 0x9D0056F4
9D0056A8  00000000   NOP
143:                 	{
144:                     	case '\f'   : 	lcd_send_byte(0,1);	break;  // modif du (1,1) en (0,1)
9D0056AC  00002021   ADDU A0, ZERO, ZERO
9D0056B0  24050001   ADDIU A1, ZERO, 1
9D0056B4  0F4015C9   JAL lcd_send_byte
9D0056B8  00000000   NOP
9D0056BC  0B4015C3   J 0x9D00570C
9D0056C0  00000000   NOP
145:                      	case '\n'   : 	lcd_gotoxy(1,2);        break;
9D0056C4  24040001   ADDIU A0, ZERO, 1
9D0056C8  24050002   ADDIU A1, ZERO, 2
9D0056CC  0F4017B9   JAL lcd_gotoxy
9D0056D0  00000000   NOP
9D0056D4  0B4015C3   J 0x9D00570C
9D0056D8  00000000   NOP
146:                      	case '\b'   : 	lcd_send_byte(0,0x10);	break;
9D0056DC  00002021   ADDU A0, ZERO, ZERO
9D0056E0  24050010   ADDIU A1, ZERO, 16
9D0056E4  0F4015C9   JAL lcd_send_byte
9D0056E8  00000000   NOP
9D0056EC  0B4015C3   J 0x9D00570C
9D0056F0  00000000   NOP
147:                      	default     : 	lcd_send_byte(1,c);		break;
9D0056F4  93C20018   LBU V0, 24(FP)
9D0056F8  24040001   ADDIU A0, ZERO, 1
9D0056FC  00402821   ADDU A1, V0, ZERO
9D005700  0F4015C9   JAL lcd_send_byte
9D005704  00000000   NOP
9D005708  00000000   NOP
148:                    }
149:                 }
9D00570C  03C0E821   ADDU SP, FP, ZERO
150:                 
151:                 /*--------------------------------------------------------*/
152:                 void lcd_put_string_ram( char *ptr_char )
153:                 {
9D006300  27BDFFE8   ADDIU SP, SP, -24
9D006304  AFBF0014   SW RA, 20(SP)
9D006308  AFBE0010   SW FP, 16(SP)
9D00630C  03A0F021   ADDU FP, SP, ZERO
9D006310  AFC40018   SW A0, 24(FP)
154:                 	while (*ptr_char != 0)
9D006314  0B4018D0   J 0x9D006340
9D006318  00000000   NOP
9D006340  8FC20018   LW V0, 24(FP)
9D006344  80420000   LB V0, 0(V0)
9D006348  1440FFF4   BNE V0, ZERO, 0x9D00631C
9D00634C  00000000   NOP
155:                 	{
156:                     	lcd_putc(*ptr_char);
9D00631C  8FC20018   LW V0, 24(FP)
9D006320  80420000   LB V0, 0(V0)
9D006324  304200FF   ANDI V0, V0, 255
9D006328  00402021   ADDU A0, V0, ZERO
9D00632C  0F401599   JAL lcd_putc
9D006330  00000000   NOP
157:                     	ptr_char++;
9D006334  8FC20018   LW V0, 24(FP)
9D006338  24420001   ADDIU V0, V0, 1
9D00633C  AFC20018   SW V0, 24(FP)
158:                   	}
159:                 }
9D006350  03C0E821   ADDU SP, FP, ZERO
160:                 
161:                 /*--------------------------------------------------------*/
162:                 void lcd_put_string_rom( const char *ptr_char )
163:                 {
164:                 	while (*ptr_char != 0)
165:                 	{
166:                     	lcd_putc(*ptr_char);
167:                     	ptr_char++;
168:                   	}
169:                 }
170:                 
171:                 /*--------------------------------------------------------*/
172:                 char lcd_getc( BYTE x, BYTE y)
173:                 {
174:                 	BYTE value;
175:                     lcd_gotoxy(x,y);
176:                     while ( lcd_read_byte() & 0x80 ); // wait until busy flag is low
177:                     LCD_RS_W = 1;
178:                     value = lcd_read_byte();
179:                     LCD_RS_W = 0;
180:                     return(value);
181:                 }
182:                 
183:                 /*--------------------------------------------------------*/
184:                 void lcd_bl_on( void )
185:                 {
9D006918  27BDFFF8   ADDIU SP, SP, -8
9D00691C  AFBE0004   SW FP, 4(SP)
9D006920  03A0F021   ADDU FP, SP, ZERO
186:                 	LCD_BL_T = 0;
9D006924  3C03BF88   LUI V1, -16504
9D006928  94626100   LHU V0, 24832(V1)
9D00692C  7C0218C4   INS V0, ZERO, 3, 1
9D006930  A4626100   SH V0, 24832(V1)
187:                 	LCD_BL_W = 1;
9D006934  3C03BF88   LUI V1, -16504
9D006938  94626120   LHU V0, 24864(V1)
9D00693C  24040001   ADDIU A0, ZERO, 1
9D006940  7C8218C4   INS V0, A0, 3, 1
9D006944  A4626120   SH V0, 24864(V1)
188:                 
189:                 }
9D006948  03C0E821   ADDU SP, FP, ZERO
190:                 
191:                 /*--------------------------------------------------------*/
192:                 void lcd_bl_off( void )
193:                 {
194:                 	LCD_BL_T = 0;
195:                 	LCD_BL_W = 0;
196:                 }
197:                 
198:                 // printf_lcd   New pour migration
199:                 // Auteur C. Huber 15.05.2014
200:                 void printf_lcd( const char *format,  ...)
201:                 {
9D006154  27BDFFC8   ADDIU SP, SP, -56
9D006158  AFBF0034   SW RA, 52(SP)
9D00615C  AFBE0030   SW FP, 48(SP)
9D006160  03A0F021   ADDU FP, SP, ZERO
9D006164  AFC5003C   SW A1, 60(FP)
9D006168  AFC60040   SW A2, 64(FP)
9D00616C  AFC70044   SW A3, 68(FP)
9D006170  AFC40038   SW A0, 56(FP)
202:                     char Buffer[21];
203:                     va_list args;
204:                     va_start(args, format);
9D006174  27C2003C   ADDIU V0, FP, 60
9D006178  AFC20028   SW V0, 40(FP)
205:                 
206:                     vsprintf(Buffer, format, args);
9D00617C  8FC20028   LW V0, 40(FP)
9D006180  27C30010   ADDIU V1, FP, 16
9D006184  00602021   ADDU A0, V1, ZERO
9D006188  8FC50038   LW A1, 56(FP)
9D00618C  00403021   ADDU A2, V0, ZERO
9D006190  0F4019AF   JAL vsprintf
9D006194  00000000   NOP
207:                     lcd_put_string_ram(Buffer);
9D006198  27C20010   ADDIU V0, FP, 16
9D00619C  00402021   ADDU A0, V0, ZERO
9D0061A0  0F4018C0   JAL lcd_put_string_ram
9D0061A4  00000000   NOP
208:                 
209:                     va_end(args);
210:                 }
9D0061A8  03C0E821   ADDU SP, FP, ZERO
211:                 
212:                 // Ajout a la demande des utilisateurs
213:                 // Auteur C. Huber 02.12.2014
214:                 void lcd_ClearLine( unsigned char NoLine)
215:                 {
216:                     int i;
217:                     if (NoLine >= 1 && NoLine <= 4)  {
218:                 
219:                         lcd_gotoxy( 1, NoLine) ;
220:                         for (i = 0 ; i < 20 ; i++)
221:                         {
222:                             lcd_send_byte(1,0x20);
223:                         }
224:                      }
225:                 }
---  c:/microchip/harmony/v2_05_01/bsp/pic32mx_skes/mc32delays.c  ---------------------------------------
1:                   /*--------------------------------------------------------*/
2:                   //	Mc32Delays.c
3:                   /*--------------------------------------------------------*/
4:                   //	Description :	Fonctions de delay afin
5:                   //			de pouvoir utiliser la même syntaxe
6:                   //			que sous CCS.
7:                   //
8:                   //	Auteurs 		: 	F. Dominé / C. Huber
9:                   //
10:                  //	Version		:	V2.0
11:                  //	Compilateur	:	nécessaire pour XC32 V 1.40
12:                  //
13:                  // Revu / modifié:
14:                  // CHR 17.12.2015    besoin du fichier maison Mc32CoreTimer.h
15:                  // SCA 11.10.2016   ajouté fonction délais core timer
16:                  /*--------------------------------------------------------*/
17:                  
18:                  
19:                  #include "Mc32Delays.h"
20:                  // Nécessaire pour la fonction delay_msCt
21:                  //#include "Mc32CoreTimer.h"
22:                  #include <xc.h> //pour les fonctions d'accès au Core Timer
23:                  #include <stdint.h>
24:                  
25:                  /*--------------------------------------------------------*/
26:                  // Fonction delay500ns
27:                  /*--------------------------------------------------------*/
28:                  void delay500ns(void)
29:                  {
30:                    // Il a fallu touiller un peu pour arriver à 500ns
31:                    // CHR 09.09.2014 avec 8 250 ns avec 9 612 ns ??????
32:                  	unsigned int cptcycles;
33:                  	  for (cptcycles=0; cptcycles < 9; cptcycles++) {
34:                  		delay_cycle();
35:                        }
36:                  }
37:                  
38:                  /*--------------------------------------------------------*/
39:                  // Fonction delay_us
40:                  /*--------------------------------------------------------*/
41:                  void delay_us(unsigned int us)
42:                  {
43:                    // Il a fallu touiller un peu pour arriver à la us
44:                    // CHR 09.09.2014 grosse retouche 17 au lieu de 3 ???????
45:                  	unsigned int i,j,cptcycles;
46:                  	for(i=1;i<=us;i++){
47:                  	  for (cptcycles=0; cptcycles < 17; cptcycles++) {
48:                  		delay_cycle();
49:                        }
50:                        if (i==us) {
51:                          delay_cycle();
52:                          delay_cycle();
53:                          delay_cycle();
54:                          delay_cycle();
55:                        }
56:                        else { //compensation des call, return, sauvegardes et restitutions
57:                          j=0;
58:                          j++;
59:                          j++;
60:                          j++;
61:                          j++;
62:                          j++;
63:                          j++;
64:                          delay_cycle();
65:                          delay_cycle();
66:                          delay_cycle();
67:                       }
68:                    }
69:                  }
70:                  /*--------------------------------------------------------*/
71:                  // Fonction delay_ms
72:                  /*--------------------------------------------------------*/
73:                  void delay_ms(unsigned int ms)
74:                  {
75:                  
76:                  	unsigned int i;
77:                  
78:                  	for(i=1;i<=ms;i++)
79:                  	{
80:                  		// 1ms = 1000us
81:                  		delay_us(1000);
82:                  	}
83:                  }
84:                  
85:                  /*--------------------------------------------------------*/
86:                  // Fonctions de délais utilisant le Core Timer
87:                  /*--------------------------------------------------------*/
88:                  //SCA 11.10.2016:
89:                  // 1. mis les fonctions du Core Timer
90:                  //  _CP0_GET_COUNT() : lecture valeur Core Timer
91:                  //  et _CP0_SET_COUNT() : écriture nouvelle valeur Core Timer
92:                  //  en dur dans ce fichier
93:                  // 2. Forcé l'optimisation 0 des fonctions delay_msCt() et delay_usCt()
94:                  // ci-dessous
95:                  // Tout ceci pour éviter toute optimisation et obtenir un comportement reproductible
96:                  //
97:                  // Fonctions testées avec MPLABX 3.40, xc32 1.42 et Harmony 1.08.01 sur Starter-kit ES
98:                  // PIC32MXF795L @ 80 MHz. Mesures :
99:                  //  Fonction    |    delta(cycles@80MHz, optimisation 0) delta(cycles@80MHz, optimisation 1)
100:                 //  ------------+---------------------------------------------------------------------------
101:                 //  delay_msCt  |    0 (exact)                           0 (exact)
102:                 //  delay_usCt  |    +3                                  +4
103:                 //  delay500nsCt|    0 (exact)                           +3 (537.5ns)
104:                 
105:                 // Les délais sont exacts en optimisation 1. 4 cycles CPU de surplus en optimisation 0
106:                 // (appels aux fonctions ? / toggle des IO ?)
107:                 
108:                 #ifndef SYS_FREQ
109:                     #define SYS_FREQ (80000000L)    //80 MHz
110:                 #endif
111:                 
112:                 //le core timer est incrémenté tous les 2 SYSCLK
113:                 #define TICK_CT_MS (SYS_FREQ / 2000L)
114:                 #define TICK_CT_US (SYS_FREQ / 2000000L)
115:                 #define TICK_OVERHEAD 15    //pour ajustement. mesuré 15 cycles Core Timer de surplus
116:                 //valeur quasi-fixe (pu observer 3 cycles CPU en plus en optimisation 0
117:                 //par rapport à 1.
118:                 
119:                 /*--------------------------------------------------------*/
120:                 // Fonction delay_msCt Core Timer
121:                 /*--------------------------------------------------------*/
122:                 //attente passive n * ms
123:                 //utilise le Core Timer
124:                 void __attribute__((optimize("-O0"))) delay_msCt(uint32_t NbMs)
125:                 {
9D005F6C  27BDFFF0   ADDIU SP, SP, -16
9D005F70  AFBF000C   SW RA, 12(SP)
9D005F74  AFBE0008   SW FP, 8(SP)
9D005F78  03A0F021   ADDU FP, SP, ZERO
9D005F7C  AFC40010   SW A0, 16(FP)
126:                     uint32_t time_to_wait;
127:                 
128:                     _CP0_SET_COUNT(0);
9D005F80  00001021   ADDU V0, ZERO, ZERO
9D005F84  40824800   MTC0 V0, Count
9D005F88  000000C0   EHB
129:                     time_to_wait = (TICK_CT_MS * NbMs) - TICK_OVERHEAD;
9D005F8C  8FC40010   LW A0, 16(FP)
9D005F90  00801821   ADDU V1, A0, ZERO
9D005F94  00031080   SLL V0, V1, 2
9D005F98  00401821   ADDU V1, V0, ZERO
9D005F9C  00031140   SLL V0, V1, 5
9D005FA0  00431023   SUBU V0, V0, V1
9D005FA4  00441021   ADDU V0, V0, A0
9D005FA8  00021880   SLL V1, V0, 2
9D005FAC  00431021   ADDU V0, V0, V1
9D005FB0  00021180   SLL V0, V0, 6
9D005FB4  2442FFF1   ADDIU V0, V0, -15
9D005FB8  AFC20000   SW V0, 0(FP)
130:                     while(_CP0_GET_COUNT()  < time_to_wait) {
9D005FBC  00000000   NOP
9D005FC0  40034800   MFC0 V1, Count
9D005FC4  8FC20000   LW V0, 0(FP)
9D005FC8  0062102B   SLTU V0, V1, V0
9D005FCC  1440FFFC   BNE V0, ZERO, 0x9D005FC0
9D005FD0  00000000   NOP
131:                         // Waiting
132:                     }
133:                 }
9D005FD4  03C0E821   ADDU SP, FP, ZERO
134:                 
135:                 /*--------------------------------------------------------*/
136:                 // Fonction delay_usCt Core Timer
137:                 /*--------------------------------------------------------*/
138:                 //attente passive n * us
139:                 //utilise le Core Timer
140:                 void __attribute__((optimize("-O0"))) delay_usCt(uint32_t NbUs)
141:                 {
9D006298  27BDFFF0   ADDIU SP, SP, -16
9D00629C  AFBF000C   SW RA, 12(SP)
9D0062A0  AFBE0008   SW FP, 8(SP)
9D0062A4  03A0F021   ADDU FP, SP, ZERO
9D0062A8  AFC40010   SW A0, 16(FP)
142:                     uint32_t time_to_wait;
143:                 
144:                     _CP0_SET_COUNT(0);
9D0062AC  00001021   ADDU V0, ZERO, ZERO
9D0062B0  40824800   MTC0 V0, Count
9D0062B4  000000C0   EHB
145:                     time_to_wait = (TICK_CT_US * NbUs) - TICK_OVERHEAD;
9D0062B8  8FC20010   LW V0, 16(FP)
9D0062BC  000210C0   SLL V0, V0, 3
9D0062C0  00021880   SLL V1, V0, 2
9D0062C4  00431021   ADDU V0, V0, V1
9D0062C8  2442FFF1   ADDIU V0, V0, -15
9D0062CC  AFC20000   SW V0, 0(FP)
146:                     while(_CP0_GET_COUNT()  < time_to_wait) {
9D0062D0  00000000   NOP
9D0062D4  40034800   MFC0 V1, Count
9D0062D8  8FC20000   LW V0, 0(FP)
9D0062DC  0062102B   SLTU V0, V1, V0
9D0062E0  1440FFFC   BNE V0, ZERO, 0x9D0062D4
9D0062E4  00000000   NOP
147:                         // Waiting
148:                     }
149:                 }
9D0062E8  03C0E821   ADDU SP, FP, ZERO
150:                 
151:                 /*--------------------------------------------------------*/
152:                 // Fonction delay500nsCt Core Timer
153:                 /*--------------------------------------------------------*/
154:                 //attente passive 500ns
155:                 //utilise le Core Timer
156:                 void __attribute__((optimize("-O0"))) delay500nsCt(void)
157:                 {
9D006840  27BDFFF8   ADDIU SP, SP, -8
9D006844  AFBF0004   SW RA, 4(SP)
9D006848  AFBE0000   SW FP, 0(SP)
9D00684C  03A0F021   ADDU FP, SP, ZERO
158:                     _CP0_SET_COUNT(0);
9D006850  00001021   ADDU V0, ZERO, ZERO
9D006854  40824800   MTC0 V0, Count
9D006858  000000C0   EHB
159:                 
160:                     while(_CP0_GET_COUNT()  < 5L) {
9D00685C  00000000   NOP
9D006860  40024800   MFC0 V0, Count
9D006864  2C420005   SLTIU V0, V0, 5
9D006868  1440FFFD   BNE V0, ZERO, 0x9D006860
9D00686C  00000000   NOP
161:                         // Waiting
162:                     }
163:                 }
9D006870  03C0E821   ADDU SP, FP, ZERO
---  c:/microchip/harmony/v2_05_01/bsp/pic32mx_skes/bsp.c  ----------------------------------------------
1:                   /*******************************************************************************
2:                     Board Support Package Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       bsp_sys_init.c
9:                   
10:                    Summary:
11:                      Board Support Package implementation for Starter Kit PIC32MX795F512L ETML-ES.
12:                  
13:                    Description:
14:                      This file contains routines that implement the board support package for
15:                      PIC32MX795F512L  Starter Kit ES.
16:                   *
17:                   *  MODIFICATIONS
18:                   *  CHR 09.12.2015 - remplacement PORT par LAT pour etablir etat out
19:                   *                 - Ajout fonction BSP_EnableHbridge
20:                   *
21:                   *  CHR 17.02.2015  - PEC12 modif car lignes séparée
22:                   *
23:                   *  CHR 18.05.2015  - Adaptation BSP_SwitchStateGet
24:                   *
25:                   *  CHR 17.09.2015  - Simplification des init car tout fait automatiquement dans
26:                   *                    SYS_PORT_INITIALIZE
27:                   *
28:                  *******************************************************************************/
29:                  
30:                  
31:                  
32:                  // *****************************************************************************
33:                  // *****************************************************************************
34:                  // Section: Included Files
35:                  // *****************************************************************************
36:                  // *****************************************************************************
37:                  
38:                  #include "bsp.h"
39:                  #include "system/devcon/sys_devcon.h"
40:                  #include "peripheral/devcon/plib_devcon.h"
41:                  
42:                  // *****************************************************************************
43:                  // *****************************************************************************
44:                  // *****************************************************************************
45:                  // Section: Interface Routines
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  
49:                  // *****************************************************************************
50:                  /* Function:
51:                      void BSP_Initialize(void)
52:                  
53:                    Summary:
54:                      Performs the necessary actions to initialize a board
55:                  
56:                  
57:                    Description:
58:                      This function initializes the LED and Switch ports on the board.  This
59:                      function must be called by the user before using any APIs present on this
60:                      BSP.
61:                  
62:                    Remarks:
63:                      Refer to bsp_config.h for usage information.
64:                  
65:                          CHR 17.09.2017 la fonction BSP_Initialize devient quasi vide suite à l'action
66:                          d'initialisation effectuée dabs SYS_PORT_INIT sur la base de bsp.xml
67:                  */
68:                  
69:                  void BSP_Initialize(void )
70:                  {
9D0065BC  27BDFFE8   ADDIU SP, SP, -24
9D0065C0  AFBF0014   SW RA, 20(SP)
9D0065C4  AFBE0010   SW FP, 16(SP)
9D0065C8  03A0F021   ADDU FP, SP, ZERO
71:                  
72:                      // Pour ne pas entrer en conflit avec le JTAG
73:                      SYS_DEVCON_JTAGDisable();     // déja fait mais si on oublie
9D0065CC  0F401AB5   JAL SYS_DEVCON_JTAGDisable
9D0065D0  00000000   NOP
74:                  
75:                      /*--------------------------------------------------------*/
76:                      // Analogique
77:                      /*--------------------------------------------------------*/
78:                      /*
79:                          TRISBbits.TRISB0 = 1; //Analog0 en entrée
80:                          TRISBbits.TRISB1 = 1; //Analog1 en entrée
81:                     */
82:                  
83:                      // CHR config AN0 et AN1 en Analogique et les autres en digital
84:                      // Nécessaire de le faire à cause des élément non configuré
85:                       PLIB_PORTS_AnPinsModeSelect(PORTS_ID_0, 0x0003, PORTS_PIN_MODE_ANALOG);
9D0065D4  00002021   ADDU A0, ZERO, ZERO
9D0065D8  24050003   ADDIU A1, ZERO, 3
9D0065DC  00003021   ADDU A2, ZERO, ZERO
9D0065E0  0F401B28   JAL PLIB_PORTS_AnPinsModeSelect
9D0065E4  00000000   NOP
86:                       PLIB_PORTS_AnPinsModeSelect(PORTS_ID_0, ~0x0003, PORTS_PIN_MODE_DIGITAL);
9D0065E8  00002021   ADDU A0, ZERO, ZERO
9D0065EC  2405FFFC   ADDIU A1, ZERO, -4
9D0065F0  24060001   ADDIU A2, ZERO, 1
9D0065F4  0F401B28   JAL PLIB_PORTS_AnPinsModeSelect
9D0065F8  00000000   NOP
87:                  
88:                      /*
89:                          PLIB_PORTS_PinModeSelect(PORTS_ID_0, PORTS_ANALOG_PIN_0, PORTS_PIN_MODE_ANALOG);
90:                          PLIB_PORTS_PinModeSelect(PORTS_ID_0, PORTS_ANALOG_PIN_1, PORTS_PIN_MODE_ANALOG);
91:                      */
92:                  
93:                  
94:                  	/*--------------------------------------------------------*/
95:                  	// Clavier matriciel
96:                  	/*--------------------------------------------------------*/
97:                  	// A l'initialisation, tout en entrée afin de ne pas avoir de problème
98:                      /*
99:                  	TRISBbits.TRISB2 = 1; //Colonne1 en entrée
100:                 	TRISBbits.TRISB3 = 1; //Colonne2 en entrée
101:                 	TRISBbits.TRISB4 = 1; //Colonne3 en entrée
102:                 	TRISBbits.TRISB5 = 1; //Colonne4 en entrée
103:                 	TRISGbits.TRISG6 = 1; //Ligne1 en entrée
104:                 	TRISGbits.TRISG7 = 1; //Ligne2 en entrée
105:                 	TRISBbits.TRISB14 = 1; //Ligne3 en entrée
106:                 	TRISBbits.TRISB15 = 1; //Ligne4 en entrée
107:                     */
108:                 
109:                 	/*--------------------------------------------------------*/
110:                 	// PEC12 -- Touches
111:                 	/*--------------------------------------------------------*/
112:                     /*
113:                 	TRISGbits.TRISG12 = 1; // S_OK  en entrée
114:                 	TRISGbits.TRISG13 = 1; // S_ESC_MENU en entrée
115:                 	TRISGbits.TRISG14 = 1; // S_PLUS en entrée
116:                 	TRISGbits.TRISG15 = 1; // S_MINUS en entrée
117:                     // PEC12 modif du 17.02.2015
118:                     TRISEbits.TRISE8 = 1 ;  // PEC12_A en input
119:                     TRISEbits.TRISE9 = 1 ;  // PEC12_B en input
120:                     TRISDbits.TRISD7 = 1 ;  // PEC12_PB en input
121:                     */
122:                 
123:                 
124:                 	/*--------------------------------------------------------*/
125:                 	// I2C
126:                 	/*--------------------------------------------------------*/
127:                 	// TRISAbits.TRISA2 = 0; //I2C_SCL en sortie
128:                 	// I2C_SDA Bidirectionnel
129:                 
130:                 	/*--------------------------------------------------------*/
131:                 	// SPI -- Chip Select
132:                 	/*--------------------------------------------------------*/
133:                     /*
134:                 	TRISDbits.TRISD3 = 0;       //CS_LM70 en sortie
135:                 	LATDbits.LATD3 = 1;         //CS_LM70 à 1
136:                 	TRISDbits.TRISD4 = 0;       //CS_DAC en sortie
137:                 	LATDbits.LATD4 = 1;         //CS_DAC à 1
138:                 	TRISDbits.TRISD5 = 0;       //CS_SD en sortie
139:                 	LATDbits.LATD5 = 1;         //CS_SD à 1
140:                     */
141:                 	/*--------------------------------------------------------*/
142:                 	// Ethernet
143:                 	/*--------------------------------------------------------*/
144:                 	// Je ne sais pas encore quoi en faire, je mets tout en entrée
145:                     // CHR par defaut en entrée si non definit
146:                     /*
147:                 	TRISDbits.TRISD6 = 1; //ETH_TX_EN en entrée
148:                 	TRISDbits.TRISD7 = 1; //ETH_TX_CLK en entrée
149:                 	TRISDbits.TRISD8 = 1; //ETH_MDIO en entrée
150:                 	TRISDbits.TRISD11 = 1; //ETH_MDC_EN en entrée
151:                 	TRISBbits.TRISB11 = 1; //ETH_RD_ER en entrée
152:                 	TRISBbits.TRISB12 = 1; //ETH_D0 en entrée
153:                 	TRISBbits.TRISB13 = 1; //ETH_D1 en entrée
154:                 	TRISAbits.TRISA14 = 1; //ETH_POWERDOWN_INT en entrée !! CHR
155:                 	TRISEbits.TRISE8 = 1; //ETH_AN_EN en entrée
156:                 	TRISEbits.TRISE9 = 1; //ETH_AN0 en entrée
157:                 	TRISFbits.TRISF0 = 1; //ETH_TX_D1 en entrée
158:                 	TRISFbits.TRISF1 = 1; //ETH_TX_D0 en entrée
159:                 	TRISGbits.TRISG8 = 1; //ETH_CRS_DV en entrée
160:                 	TRISGbits.TRISG8 = 1; //ETH_RST en entrée
161:                     */
162:                 
163:                 	/*----------------------------------------------------*/
164:                 	// SD Card
165:                 	/*----------------------------------------------------*/
166:                 	// TRISCbits.TRISC3 = 1; //SD_DETECT en entrée
167:                 
168:                 	/*----------------------------------------------------*/
169:                 	// DAC
170:                 	/*----------------------------------------------------*/
171:                 	// TRISDbits.TRISD9 = 0; //DAC_CLEAR en sortie
172:                 	// LATDbits.LATD9 = 1; //DAC_CLEAR = 1
173:                 
174:                 	/*----------------------------------------------------*/
175:                 	// LEDs
176:                 	/*----------------------------------------------------*/
177:                 
178:                     /*
179:                 	LED0_T = 0; //LED_D6  (Led0) en sortie
180:                 	LED0_W = 1; //LED_D6  (Led0) = 1
181:                 	LED1_T = 0; //LED_D10 (Led1) en sortie
182:                 	LED1_W = 1; //LED_D10 (Led1) = 1
183:                 	LED2_T = 0; //LED_D7  (Led2) en sortie
184:                 	LED2_W = 1; //LED_D7  (Led2) = 1
185:                 	LED3_T = 0; //LED_D11 (Led3) en sortie
186:                 	LED3_W = 1; //LED_D11 (Led3) = 1
187:                 	LED4_T = 0; //LED_D8  (Led4) en sortie
188:                 	LED4_W = 1; //LED_D8  (Led4) = 1
189:                 	LED5_T = 0; //LED_D12 (Led5) en sortie
190:                 	LED5_W = 1; //LED_D12 (Led5) = 1
191:                 	LED6_T = 0; //LED_D9  (Led6) en sortie
192:                 	LED6_W = 1; //LED_D9  (Led6) = 1
193:                 	LED7_T = 0; //LED_D13 (Led7) en sortie
194:                 	LED7_W = 1; //LED_D13 (Led7) = 1
195:                     */
196:                 
197:                 	/*--------------------------------------------------------*/
198:                 	// USB
199:                 	/*--------------------------------------------------------*/
200:                 	// TRISFbits.TRISF3 = 1; //USB_DETECT en entrée
201:                 	// TRISGbits.TRISG2 = 1; //USB_PLUS en entrée par sécurité
202:                 	// TRISGbits.TRISG3 = 1; //USB_MINUS en entrée par sécurité
203:                 
204:                 	/*--------------------------------------------------------*/
205:                 	// RS232
206:                 	/*--------------------------------------------------------*/
207:                     /*
208:                 	TRISFbits.TRISF8 = 0; //RS232_TX en sortie
209:                 	LATFbits.LATF8 = 1; //RS232_TX à 1
210:                 	TRISFbits.TRISF2 = 1; //RS232_RX en entrée
211:                 	TRISDbits.TRISD15 = 0; //RS232_RTS en sortie
212:                 	LATDbits.LATD15 = 1; //RS232_RTS à 1
213:                 	TRISDbits.TRISD14 = 1; //RS232_CTS en entrée
214:                     */
215:                 
216:                 	/*--------------------------------------------------------*/
217:                 	// LCD
218:                 	/*--------------------------------------------------------*/
219:                 	// On met d'abord toutes les pattes du LCD à 1 sauf le backlight
220:                     /*
221:                     LCD_RS_W = 1;
222:                     LCD_RW_W = 1;
223:                     LCD_E_W = 1;
224:                     LCD_BL_W = 0;
225:                     LCD_DB4_W = 1;
226:                     LCD_DB5_W = 1;
227:                     LCD_DB6_W = 1;
228:                     LCD_DB7_W = 1;
229:                     */
230:                     // Puis on configure toutes les pattes en sortie, lorsqu'on aura besoin, on modifiera
231:                     // ce qu'il faut en entrée
232:                     /*
233:                 	LCD_RS_T = 0; //LCD_RS en sortie
234:                 	LCD_RW_T = 0; //LCD_RW en sortie
235:                 	LCD_E_T = 0; //LCD_E en sortie
236:                 	LCD_BL_T = 0; //LCD_BL en sortie
237:                 	LCD_DB4_T = 0; //LCD_DB4 en sortie
238:                 	LCD_DB5_T = 0; //LCD_DB5 en sortie
239:                 	LCD_DB6_T = 0; //LCD_DB6 en sortie
240:                 	LCD_DB7_T = 0; //LCD_DB7 en sortie
241:                     */
242:                 	/*--------------------------------------------------------*/
243:                 	// Pont en H
244:                 	/*--------------------------------------------------------*/
245:                 	// Tout en sortie mais à 0
246:                 
247:                 
248:                 	/*--------------------------------------------------------*/
249:                 	// XBee
250:                 	/*--------------------------------------------------------*/
251:                     /*
252:                 	TRISFbits.TRISF5 = 0; //XBEE_TX en sortie
253:                 	LATFbits.LATF5 = 1; //XBEE_TX = 1
254:                 	TRISFbits.TRISF4 = 1; //XBEE_RX en entrée
255:                 	TRISFbits.TRISF13 = 0; //XBEE_RTS en sortie
256:                 	LATFbits.LATF13 = 1; //XBEE_RTS = 1
257:                 	TRISFbits.TRISF12 = 1; //XBEE_CTS en entrée
258:                 	TRISGbits.TRISG0 = 1; //XBEE_ON_SLEEP en entrée
259:                 	TRISGbits.TRISG1 = 0; //XBEE_RESET en sortie
260:                 	LATGbits.LATG1 = 1; //XBEE_RESET = 1
261:                     */
262:                 }
9D0065FC  03C0E821   ADDU SP, FP, ZERO
263:                 
264:                 // *****************************************************************************
265:                 /* Function:
266:                     void BSP_LEDStateSet(BSP_LED led, BSP_LED_STATE state);
267:                 
268:                   Summary:
269:                     Controls the state of the LED.
270:                 
271:                   Description:
272:                     This function allows the application to specify the state of the LED.
273:                 
274:                   Adaptation:
275:                      CHR 08.09.2014  adaptation au 8 led du KIT ES.
276:                 */
277:                 
278:                 void BSP_LEDStateSet(BSP_LED led, BSP_LED_STATE state)
279:                 {
280:                     /* Switch ON the LED */
281:                     if (led == BSP_LED_7) {
282:                         PLIB_PORTS_PinWrite ( PORTS_ID_0 , PORT_CHANNEL_B , led, state );
283:                     } else {
284:                         PLIB_PORTS_PinWrite ( PORTS_ID_0 , PORT_CHANNEL_A , led, state );
285:                     }
286:                 
287:                 }
288:                 
289:                 // *****************************************************************************
290:                 /* Function:
291:                     void BSP_LEDOn(BSP_LED led);
292:                 
293:                   Summary:
294:                     Switches ON the specified LED.
295:                 
296:                   Description:
297:                     This function switches ON the specified LED.
298:                 
299:                   Adaptation:
300:                      CHR 08.09.2014  adaptation au 8 led du KIT ES.
301:                 */
302:                 
303:                 void BSP_LEDOn(BSP_LED led)
304:                 {
305:                     // Led On pour Clear
306:                     if (led == BSP_LED_7) {
307:                         PLIB_PORTS_PinClear( PORTS_ID_0, PORT_CHANNEL_B, led);
308:                     } else {
309:                         PLIB_PORTS_PinClear( PORTS_ID_0, PORT_CHANNEL_A, led);
310:                     }
311:                 }
312:                 
313:                 // *****************************************************************************
314:                 /* Function:
315:                     void BSP_LEDOff(BSP_LED led);
316:                 
317:                   Summary:
318:                     Switches OFF the specified LED.
319:                 
320:                   Description:
321:                     This function switches OFF the specified LED.
322:                 
323:                   Adaptation:
324:                      CHR 08.09.2014  adaptation au 8 led du KIT ES.
325:                 */
326:                 
327:                 void BSP_LEDOff(BSP_LED led)
328:                 {
329:                     // Led Off pour Set
330:                     if (led == BSP_LED_7) {
331:                         PLIB_PORTS_PinSet( PORTS_ID_0, PORT_CHANNEL_B, led);
332:                     } else {
333:                         PLIB_PORTS_PinSet( PORTS_ID_0, PORT_CHANNEL_A, led);
334:                     }
335:                 }
336:                 
337:                 // *****************************************************************************
338:                 /* Function:
339:                     BSP_LED_STATE BSP_LEDStateGet(BSP_LED led);
340:                 
341:                   Summary:
342:                     Returns the present state of the LED.
343:                 
344:                   Description:
345:                     This function returns the present state of the LED.
346:                 
347:                   Adaptation:
348:                      CHR 08.09.2014  adaptation au 8 led du KIT ES.
349:                 */
350:                 
351:                 BSP_LED_STATE BSP_LEDStateGet(BSP_LED led)
352:                 {
353:                     BSP_LED_STATE tmp;
354:                 
355:                     if (led == BSP_LED_7) {
356:                         tmp = PLIB_PORTS_PinGetLatched(PORTS_ID_0, PORT_CHANNEL_B, led);
357:                     } else {
358:                         tmp = PLIB_PORTS_PinGetLatched(PORTS_ID_0, PORT_CHANNEL_A, led);
359:                     }
360:                     return(tmp);
361:                 }
362:                 
363:                 // *****************************************************************************
364:                 /* Function:
365:                     void BSP_LEDToggle(BSP_LED led);
366:                 
367:                   Summary:
368:                     Toggles the state of the LED between BSP_LED_STATE_ON and BSP_LED_STATE_OFF.
369:                 
370:                   Description:
371:                     This function toggles the state of the LED between BSP_LED_STATE_ON and
372:                     BSP_LED_STATE_OFF.
373:                 
374:                   Adaptation:
375:                      CHR 08.09.2014  adaptation au 8 led du KIT ES.
376:                 */
377:                 
378:                 void BSP_LEDToggle(BSP_LED led)
379:                 {
380:                     if (led == BSP_LED_7) {
381:                         PLIB_PORTS_PinToggle(PORTS_ID_0, PORT_CHANNEL_B,led );
382:                     } else {
383:                         PLIB_PORTS_PinToggle(PORTS_ID_0, PORT_CHANNEL_A,led );
384:                     }
385:                 
386:                 }
387:                 
388:                 // *****************************************************************************
389:                 /* Function:
390:                     void BSP_SwitchStateGet(BSP_SWITCH switch);
391:                 
392:                   Summary:
393:                     Returns the present state (pressed or not pressed) of the specified switch.
394:                 
395:                   Description:
396:                     This function returns the present state (pressed or not pressed) of the
397:                     specified switch.
398:                 
399:                   Remarks:
400:                     None.
401:                 */
402:                 
403:                 
404:                 // CHR les switch sont sur le port G
405:                 BSP_SWITCH_STATE BSP_SwitchStateGet( BSP_SWITCH bspSwitch )
406:                 {
407:                     return ( PLIB_PORTS_PinGet(PORTS_ID_0, PORT_CHANNEL_G, bspSwitch) );
408:                 }
409:                 
410:                 
411:                 // ajout 9.12.2014
412:                 // correction STBY_HBRIDGE 30.01.2015
413:                 void BSP_EnableHbrige(void)
414:                 {
415:                     TRISBbits.TRISB8 = 0; //STBY_HBRIDGE en sortie
416:                     STBY_HBRIDGE_W = 0;   // STBY low durant init
417:                 
418:                 	TRISDbits.TRISD12 = 0; //AIN1_HBRIDGE en sortie
419:                 	TRISDbits.TRISD13 = 0; //AIN2_HBRIDGE en sortie
420:                     // Ne pas toucher PWM à cause init OC avant
421:                 	// TRISDbits.TRISD1 = 0;  //PWMA_HBRIDGE en sortie
422:                     // Mise en short brake PWM dont care
423:                     AIN1_HBRIDGE_W = 1;   //AIN1 High
424:                 	AIN2_HBRIDGE_W = 1;  //AIN2 High
425:                 	// PWMA_HBRIDGE_W = 0;  //PWMA low
426:                 
427:                 	TRISCbits.TRISC1 = 0; //BIN1_HBRIDGE en sortie
428:                 	TRISCbits.TRISC2 = 0; //BIN2_HBRIDGE en sortie
429:                     // Ne pas toucher PWM à cause init OC avant
430:                 	// TRISDbits.TRISD2 = 0; //PWMB_HBRIDGE en sortie
431:                 
432:                     // Mise en short brake PWM dont care
433:                     BIN1_HBRIDGE_W = 1;   //BIN1 High
434:                 	BIN2_HBRIDGE_W = 1;   //BIN2 High
435:                 	// PWMB_HBRIDGE_W = 0;   //PWMB low
436:                 
437:                     STBY_HBRIDGE_W = 1;   // STBY High
438:                 }
439:                 
440:                 /*******************************************************************************
441:                  End of File
442:                 */
---  c:/microchip/harmony/v2_05_01/apps/minf/epreuves/te_frqmtr32bits/firmware/src/system_config/default/system_tasks.c
1:                   /*******************************************************************************
2:                    System Tasks File
3:                   
4:                     File Name:
5:                       system_tasks.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to maintain system's polled state
9:                       machines.
10:                  
11:                    Description:
12:                      This file contains source code necessary to maintain system's polled state
13:                      machines.  It implements the "SYS_Tasks" function that calls the individual
14:                      "Tasks" functions for all polled MPLAB Harmony modules in the system.
15:                  
16:                    Remarks:
17:                      This file requires access to the systemObjects global data structure that
18:                      contains the object handles to all MPLAB Harmony module objects executing
19:                      polled in the system.  These handles are passed into the individual module
20:                      "Tasks" functions to identify the instance of the module to maintain.
21:                   *******************************************************************************/
22:                  
23:                  // DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                   *******************************************************************************/
46:                  // DOM-IGNORE-END
47:                  
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  // Section: Included Files
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  
54:                  #include "system_config.h"
55:                  #include "system_definitions.h"
56:                  
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: System "Tasks" Routine
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  /*******************************************************************************
65:                    Function:
66:                      void SYS_Tasks ( void )
67:                  
68:                    Remarks:
69:                      See prototype in system/common/sys_module.h.
70:                  */
71:                  
72:                  void SYS_Tasks ( void )
73:                  {
9D006B08  27BDFFE8   ADDIU SP, SP, -24
9D006B0C  AFBF0014   SW RA, 20(SP)
9D006B10  AFBE0010   SW FP, 16(SP)
9D006B14  03A0F021   ADDU FP, SP, ZERO
74:                      /* Maintain system services */
75:                  
76:                      /* Maintain Device Drivers */
77:                  
78:                      /* Maintain Middleware & Other Libraries */
79:                  
80:                      /* Maintain the application's state machine. */
81:                      APP_Tasks();
9D006B18  0F400D90   JAL APP_Tasks
9D006B1C  00000000   NOP
82:                  }
9D006B20  03C0E821   ADDU SP, FP, ZERO
83:                  
84:                  
85:                  /*******************************************************************************
86:                   End of File
87:                   */
88:                  
---  c:/microchip/harmony/v2_05_01/apps/minf/epreuves/te_frqmtr32bits/firmware/src/system_config/default/system_interrupt.c
1:                   /*******************************************************************************
2:                    System Interrupts File
3:                   
4:                     File Name:
5:                       system_interrupt.c
6:                   
7:                     Summary:
8:                       Raw ISR definitions.
9:                   
10:                    Description:
11:                      This file contains a definitions of the raw ISRs required to support the
12:                      interrupt sub-system.
13:                  
14:                    Summary:
15:                      This file contains source code for the interrupt vector functions in the
16:                      system.
17:                  
18:                    Description:
19:                      This file contains source code for the interrupt vector functions in the
20:                      system.  It implements the system and part specific vector "stub" functions
21:                      from which the individual "Tasks" functions are called for any modules
22:                      executing interrupt-driven in the MPLAB Harmony system.
23:                  
24:                    Remarks:
25:                      This file requires access to the systemObjects global data structure that
26:                      contains the object handles to all MPLAB Harmony module objects executing
27:                      interrupt-driven in the system.  These handles are passed into the individual
28:                      module "Tasks" functions to identify the instance of the module to maintain.
29:                   *******************************************************************************/
30:                  
31:                  // DOM-IGNORE-BEGIN
32:                  /*******************************************************************************
33:                  Copyright (c) 2011-2014 released Microchip Technology Inc.  All rights reserved.
34:                  
35:                  Microchip licenses to you the right to use, modify, copy and distribute
36:                  Software only when embedded on a Microchip microcontroller or digital signal
37:                  controller that is integrated into your product or third party product
38:                  (pursuant to the sublicense terms in the accompanying license agreement).
39:                  
40:                  You should refer to the license agreement accompanying this Software for
41:                  additional information regarding your rights and obligations.
42:                  
43:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
44:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
45:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
46:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
47:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
48:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
49:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
50:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
51:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
52:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
53:                   *******************************************************************************/
54:                  // DOM-IGNORE-END
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Included Files
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  
62:                  #include "system/common/sys_common.h"
63:                  #include "app.h"
64:                  #include "system_definitions.h"
65:                  #include "peripheral/ic/plib_ic.h"
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: System Interrupt Vector Functions
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                  
74:                  //timer 1 16 bits @ 20 Hz
75:                  void __ISR(_TIMER_1_VECTOR, ipl1AUTO) IntHandlerDrvTmrInstance0(void)
76:                  {
9D004490  415DE800   RDPGPR SP, SP
9D004494  401B7000   MFC0 K1, EPC
9D004498  401A6002   MFC0 K0, SRSCtl
9D00449C  27BDFF88   ADDIU SP, SP, -120
9D0044A0  AFBB0074   SW K1, 116(SP)
9D0044A4  401B6000   MFC0 K1, Status
9D0044A8  AFBA006C   SW K0, 108(SP)
9D0044AC  AFBB0070   SW K1, 112(SP)
9D0044B0  7C1B7844   INS K1, ZERO, 1, 15
9D0044B4  377B0400   ORI K1, K1, 1024
9D0044B8  409B6000   MTC0 K1, Status
9D0044BC  AFA3001C   SW V1, 28(SP)
9D0044C0  AFA20018   SW V0, 24(SP)
9D0044C4  8FA3006C   LW V1, 108(SP)
9D0044C8  3063000F   ANDI V1, V1, 15
9D0044CC  14600012   BNE V1, ZERO, 0x9D004518
9D0044D0  00000000   NOP
9D0044D4  AFBF005C   SW RA, 92(SP)
9D0044D8  AFBE0058   SW FP, 88(SP)
9D0044DC  AFB90054   SW T9, 84(SP)
9D0044E0  AFB80050   SW T8, 80(SP)
9D0044E4  AFAF004C   SW T7, 76(SP)
9D0044E8  AFAE0048   SW T6, 72(SP)
9D0044EC  AFAD0044   SW T5, 68(SP)
9D0044F0  AFAC0040   SW T4, 64(SP)
9D0044F4  AFAB003C   SW T3, 60(SP)
9D0044F8  AFAA0038   SW T2, 56(SP)
9D0044FC  AFA90034   SW T1, 52(SP)
9D004500  AFA80030   SW T0, 48(SP)
9D004504  AFA7002C   SW A3, 44(SP)
9D004508  AFA60028   SW A2, 40(SP)
9D00450C  AFA50024   SW A1, 36(SP)
9D004510  AFA40020   SW A0, 32(SP)
9D004514  AFA10014   SW AT, 20(SP)
9D004518  00000000   NOP
9D00451C  00001012   MFLO V0
9D004520  AFA20064   SW V0, 100(SP)
9D004524  00001810   MFHI V1
9D004528  AFA30060   SW V1, 96(SP)
9D00452C  03A0F021   ADDU FP, SP, ZERO
77:                      PLIB_INT_SourceFlagClear(INT_ID_0,INT_SOURCE_TIMER_1);
9D004530  00002021   ADDU A0, ZERO, ZERO
9D004534  24050004   ADDIU A1, ZERO, 4
9D004538  0F401AF8   JAL PLIB_INT_SourceFlagClear
9D00453C  00000000   NOP
78:                      
79:                      APP_UpdateState(APP_STATE_SERVICE_TASKS);
9D004540  24040002   ADDIU A0, ZERO, 2
9D004544  0F401ACE   JAL APP_UpdateState
9D004548  00000000   NOP
80:                      
81:                      LED0_W = ~LED0_R;
9D00454C  3C02BF88   LUI V0, -16504
9D004550  8C426010   LW V0, 24592(V0)
9D004554  7C420000   EXT V0, V0, 0, 1
9D004558  304200FF   ANDI V0, V0, 255
9D00455C  00021027   NOR V0, ZERO, V0
9D004560  304200FF   ANDI V0, V0, 255
9D004564  30420001   ANDI V0, V0, 1
9D004568  304400FF   ANDI A0, V0, 255
9D00456C  3C03BF88   LUI V1, -16504
9D004570  94626020   LHU V0, 24608(V1)
9D004574  7C820004   INS V0, A0, 0, 1
9D004578  A4626020   SH V0, 24608(V1)
82:                  }
9D00457C  03C0E821   ADDU SP, FP, ZERO
83:                  
84:                  
85:                  //timer 2-3 32 bits
86:                  void __ISR(_TIMER_3_VECTOR, ipl0AUTO) IntHandlerDrvTmrInstance1(void)
87:                  {
9D00461C  415DE800   RDPGPR SP, SP
9D004620  401B7000   MFC0 K1, EPC
9D004624  401A6002   MFC0 K0, SRSCtl
9D004628  27BDFF88   ADDIU SP, SP, -120
9D00462C  AFBB0074   SW K1, 116(SP)
9D004630  401B6000   MFC0 K1, Status
9D004634  AFBA006C   SW K0, 108(SP)
9D004638  AFBB0070   SW K1, 112(SP)
9D00463C  7C1B7844   INS K1, ZERO, 1, 15
9D004640  377B0000   ORI K1, K1, 0
9D004644  409B6000   MTC0 K1, Status
9D004648  AFA3001C   SW V1, 28(SP)
9D00464C  AFA20018   SW V0, 24(SP)
9D004650  8FA3006C   LW V1, 108(SP)
9D004654  3063000F   ANDI V1, V1, 15
9D004658  14600012   BNE V1, ZERO, 0x9D0046A4
9D00465C  00000000   NOP
9D004660  AFBF005C   SW RA, 92(SP)
9D004664  AFBE0058   SW FP, 88(SP)
9D004668  AFB90054   SW T9, 84(SP)
9D00466C  AFB80050   SW T8, 80(SP)
9D004670  AFAF004C   SW T7, 76(SP)
9D004674  AFAE0048   SW T6, 72(SP)
9D004678  AFAD0044   SW T5, 68(SP)
9D00467C  AFAC0040   SW T4, 64(SP)
9D004680  AFAB003C   SW T3, 60(SP)
9D004684  AFAA0038   SW T2, 56(SP)
9D004688  AFA90034   SW T1, 52(SP)
9D00468C  AFA80030   SW T0, 48(SP)
9D004690  AFA7002C   SW A3, 44(SP)
9D004694  AFA60028   SW A2, 40(SP)
9D004698  AFA50024   SW A1, 36(SP)
9D00469C  AFA40020   SW A0, 32(SP)
9D0046A0  AFA10014   SW AT, 20(SP)
9D0046A4  00000000   NOP
9D0046A8  00001012   MFLO V0
9D0046AC  AFA20064   SW V0, 100(SP)
9D0046B0  00001810   MFHI V1
9D0046B4  AFA30060   SW V1, 96(SP)
9D0046B8  03A0F021   ADDU FP, SP, ZERO
88:                      PLIB_INT_SourceFlagClear(INT_ID_0,INT_SOURCE_TIMER_3);
9D0046BC  00002021   ADDU A0, ZERO, ZERO
9D0046C0  2405000C   ADDIU A1, ZERO, 12
9D0046C4  0F401AF8   JAL PLIB_INT_SourceFlagClear
9D0046C8  00000000   NOP
89:                      
90:                      LED1_W = ~LED1_R;
9D0046CC  3C02BF88   LUI V0, -16504
9D0046D0  8C426010   LW V0, 24592(V0)
9D0046D4  7C420040   EXT V0, V0, 1, 1
9D0046D8  304200FF   ANDI V0, V0, 255
9D0046DC  00021027   NOR V0, ZERO, V0
9D0046E0  304200FF   ANDI V0, V0, 255
9D0046E4  30420001   ANDI V0, V0, 1
9D0046E8  304400FF   ANDI A0, V0, 255
9D0046EC  3C03BF88   LUI V1, -16504
9D0046F0  94626020   LHU V0, 24608(V1)
9D0046F4  7C820844   INS V0, A0, 1, 1
9D0046F8  A4626020   SH V0, 24608(V1)
91:                  }
9D0046FC  03C0E821   ADDU SP, FP, ZERO
92:                  
93:                  void __ISR(_INPUT_CAPTURE_5_VECTOR, ipl7AUTO) _IntHandlerDrvICInstance0(void)
94:                  {
9D0042E4  415DE800   RDPGPR SP, SP
9D0042E8  401B7000   MFC0 K1, EPC
9D0042EC  401A6002   MFC0 K0, SRSCtl
9D0042F0  27BDFF88   ADDIU SP, SP, -120
9D0042F4  401B6000   MFC0 K1, Status
9D0042F8  AFBA0070   SW K0, 112(SP)
9D0042FC  AFBB0074   SW K1, 116(SP)
9D004300  7C1B7844   INS K1, ZERO, 1, 15
9D004304  377B1C00   ORI K1, K1, 7168
9D004308  409B6000   MTC0 K1, Status
9D00430C  AFA3001C   SW V1, 28(SP)
9D004310  AFA20018   SW V0, 24(SP)
9D004314  8FA30070   LW V1, 112(SP)
9D004318  3063000F   ANDI V1, V1, 15
9D00431C  14600012   BNE V1, ZERO, 0x9D004368
9D004320  00000000   NOP
9D004324  AFBF005C   SW RA, 92(SP)
9D004328  AFBE0058   SW FP, 88(SP)
9D00432C  AFB90054   SW T9, 84(SP)
9D004330  AFB80050   SW T8, 80(SP)
9D004334  AFAF004C   SW T7, 76(SP)
9D004338  AFAE0048   SW T6, 72(SP)
9D00433C  AFAD0044   SW T5, 68(SP)
9D004340  AFAC0040   SW T4, 64(SP)
9D004344  AFAB003C   SW T3, 60(SP)
9D004348  AFAA0038   SW T2, 56(SP)
9D00434C  AFA90034   SW T1, 52(SP)
9D004350  AFA80030   SW T0, 48(SP)
9D004354  AFA7002C   SW A3, 44(SP)
9D004358  AFA60028   SW A2, 40(SP)
9D00435C  AFA50024   SW A1, 36(SP)
9D004360  AFA40020   SW A0, 32(SP)
9D004364  AFA10014   SW AT, 20(SP)
9D004368  00000000   NOP
9D00436C  00001012   MFLO V0
9D004370  AFA20064   SW V0, 100(SP)
9D004374  00001810   MFHI V1
9D004378  AFA30060   SW V1, 96(SP)
9D00437C  03A0F021   ADDU FP, SP, ZERO
95:                      LED2_W = 1;
9D004380  3C03BF88   LUI V1, -16504
9D004384  94626020   LHU V0, 24608(V1)
9D004388  24040001   ADDIU A0, ZERO, 1
9D00438C  7C822104   INS V0, A0, 4, 1
9D004390  A4626020   SH V0, 24608(V1)
96:                      
97:                      //vider buffer capture
98:                      while(!PLIB_IC_BufferIsEmpty(IC_ID_5))
9D004394  0B4010F0   J 0x9D0043C0
9D004398  00000000   NOP
9D0043C0  3C02BF80   LUI V0, -16512
9D0043C4  34442800   ORI A0, V0, 10240
9D0043C8  0F401BBD   JAL PLIB_IC_BufferIsEmpty
9D0043CC  00000000   NOP
9D0043D0  38420001   XORI V0, V0, 1
9D0043D4  304200FF   ANDI V0, V0, 255
9D0043D8  1440FFF0   BNE V0, ZERO, 0x9D00439C
9D0043DC  00000000   NOP
99:                      {
100:                         capturedValues[1] = capturedValues[0];
9D00439C  8F828024   LW V0, -32732(GP)
9D0043A0  AF828028   SW V0, -32728(GP)
101:                         capturedValues[0] = PLIB_IC_Buffer32BitGet(IC_ID_5);
9D0043A4  3C02BF80   LUI V0, -16512
9D0043A8  34442800   ORI A0, V0, 10240
9D0043AC  0F401BD1   JAL PLIB_IC_Buffer32BitGet
9D0043B0  00000000   NOP
9D0043B4  AF828024   SW V0, -32732(GP)
102:                         newValue = true;
9D0043B8  24020001   ADDIU V0, ZERO, 1
9D0043BC  A382802C   SB V0, -32724(GP)
103:                     }
104:                     
105:                     //quittace interrupt
106:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_INPUT_CAPTURE_5);
9D0043E0  00002021   ADDU A0, ZERO, ZERO
9D0043E4  24050015   ADDIU A1, ZERO, 21
9D0043E8  0F401AF8   JAL PLIB_INT_SourceFlagClear
9D0043EC  00000000   NOP
107:                     
108:                     LED2_W = 0;
9D0043F0  3C03BF88   LUI V1, -16504
9D0043F4  94626020   LHU V0, 24608(V1)
9D0043F8  7C022104   INS V0, ZERO, 4, 1
9D0043FC  A4626020   SH V0, 24608(V1)
109:                 }
9D004400  03C0E821   ADDU SP, FP, ZERO
110:                 /*******************************************************************************
111:                  End of File
112:                 */
---  c:/microchip/harmony/v2_05_01/apps/minf/epreuves/te_frqmtr32bits/firmware/src/system_config/default/system_init.c
1:                   /*******************************************************************************
2:                     System Initialization File
3:                   
4:                     File Name:
5:                       system_init.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to initialize the system.
9:                   
10:                    Description:
11:                      This file contains source code necessary to initialize the system.  It
12:                      implements the "SYS_Initialize" function, defines the configuration bits,
13:                      and allocates any necessary global system resources, such as the
14:                      sysObj structure that contains the object handles to all the MPLAB Harmony
15:                      module objects in the system.
16:                   *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                   *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  // *****************************************************************************
44:                  // *****************************************************************************
45:                  // Section: Included Files
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  
49:                  #include "system_config.h"
50:                  #include "system_definitions.h"
51:                  
52:                  
53:                  // ****************************************************************************
54:                  // ****************************************************************************
55:                  // Section: Configuration Bits
56:                  // ****************************************************************************
57:                  // ****************************************************************************
58:                  // <editor-fold defaultstate="collapsed" desc="Configuration Bits">
59:                  
60:                  /*** DEVCFG0 ***/
61:                  
62:                  #pragma config DEBUG =      ON
63:                  #pragma config ICESEL =     ICS_PGx2
64:                  #pragma config PWP =        OFF
65:                  #pragma config BWP =        OFF
66:                  #pragma config CP =         OFF
67:                  
68:                  /*** DEVCFG1 ***/
69:                  
70:                  #pragma config FNOSC =      PRIPLL
71:                  #pragma config FSOSCEN =    OFF
72:                  #pragma config IESO =       OFF
73:                  #pragma config POSCMOD =    XT
74:                  #pragma config OSCIOFNC =   OFF
75:                  #pragma config FPBDIV =     DIV_1
76:                  #pragma config FCKSM =      CSECMD
77:                  #pragma config WDTPS =      PS1048576
78:                  #pragma config FWDTEN =     OFF
79:                  /*** DEVCFG2 ***/
80:                  
81:                  #pragma config FPLLIDIV =   DIV_2
82:                  #pragma config FPLLMUL =    MUL_20
83:                  #pragma config FPLLODIV =   DIV_1
84:                  #pragma config UPLLIDIV =   DIV_2
85:                  #pragma config UPLLEN =     ON
86:                  /*** DEVCFG3 ***/
87:                  
88:                  #pragma config USERID =     0xffff
89:                  #pragma config FSRSSEL =    PRIORITY_7
90:                  #pragma config FMIIEN =     OFF
91:                  #pragma config FETHIO =     ON
92:                  #pragma config FCANIO =     ON
93:                  #pragma config FUSBIDIO =   ON
94:                  #pragma config FVBUSONIO =  ON
95:                  // </editor-fold>
96:                  
97:                  // *****************************************************************************
98:                  // *****************************************************************************
99:                  // Section: Driver Initialization Data
100:                 // *****************************************************************************
101:                 // *****************************************************************************
102:                 // <editor-fold defaultstate="collapsed" desc="DRV_Timer Initialization Data">
103:                 // </editor-fold>
104:                 
105:                 // *****************************************************************************
106:                 // *****************************************************************************
107:                 // Section: System Data
108:                 // *****************************************************************************
109:                 // *****************************************************************************
110:                 
111:                 /* Structure to hold the object handles for the modules in the system. */
112:                 SYSTEM_OBJECTS sysObj;
113:                 
114:                 // *****************************************************************************
115:                 // *****************************************************************************
116:                 // Section: Module Initialization Data
117:                 // *****************************************************************************
118:                 // *****************************************************************************
119:                 
120:                 // *****************************************************************************
121:                 // *****************************************************************************
122:                 // Section: Library/Stack Initialization Data
123:                 // *****************************************************************************
124:                 // *****************************************************************************
125:                 
126:                 // *****************************************************************************
127:                 // *****************************************************************************
128:                 // Section: System Initialization
129:                 // *****************************************************************************
130:                 // *****************************************************************************
131:                 
132:                 /*******************************************************************************
133:                   Function:
134:                     void SYS_Initialize ( void *data )
135:                 
136:                   Summary:
137:                     Initializes the board, services, drivers, application and other modules.
138:                 
139:                   Remarks:
140:                     See prototype in system/common/sys_module.h.
141:                  */
142:                 
143:                 void SYS_Initialize ( void* data )
144:                 {
9D005958  27BDFFE8   ADDIU SP, SP, -24
9D00595C  AFBF0014   SW RA, 20(SP)
9D005960  AFBE0010   SW FP, 16(SP)
9D005964  03A0F021   ADDU FP, SP, ZERO
9D005968  AFC40018   SW A0, 24(FP)
145:                     /* Core Processor Initialization */
146:                     SYS_CLK_Initialize( NULL );
9D00596C  00002021   ADDU A0, ZERO, ZERO
9D005970  0F401927   JAL SYS_CLK_Initialize
9D005974  00000000   NOP
147:                     SYS_DEVCON_Initialize(SYS_DEVCON_INDEX_0, (SYS_MODULE_INIT*)NULL);
9D005978  00002021   ADDU A0, ZERO, ZERO
9D00597C  00002821   ADDU A1, ZERO, ZERO
9D005980  0F401A99   JAL SYS_DEVCON_Initialize
9D005984  00000000   NOP
148:                     SYS_DEVCON_PerformanceConfig(SYS_CLK_SystemFrequencyGet());
9D005988  0F401AE4   JAL SYS_CLK_SystemFrequencyGet
9D00598C  00000000   NOP
9D005990  00402021   ADDU A0, V0, ZERO
9D005994  0F4011E7   JAL SYS_DEVCON_PerformanceConfig
9D005998  00000000   NOP
149:                     SYS_DEVCON_JTAGDisable();
9D00599C  0F401AB5   JAL SYS_DEVCON_JTAGDisable
9D0059A0  00000000   NOP
150:                     SYS_PORTS_Initialize();
9D0059A4  0F400FC3   JAL SYS_PORTS_Initialize
9D0059A8  00000000   NOP
151:                 
152:                     /* Board Support Package Initialization */
153:                     BSP_Initialize();        
9D0059AC  0F40196F   JAL BSP_Initialize
9D0059B0  00000000   NOP
154:                 
155:                     /* Initialize Drivers */
156:                     /* Initialize the IC Driver */
157:                     DRV_IC0_Initialize();
9D0059B4  0F401568   JAL DRV_IC0_Initialize
9D0059B8  00000000   NOP
158:                     /*Initialize TMR0 */
159:                     DRV_TMR0_Initialize();
9D0059BC  0F4015F8   JAL DRV_TMR0_Initialize
9D0059C0  00000000   NOP
160:                     /*Initialize TMR1 */
161:                     DRV_TMR1_Initialize();
9D0059C4  0F401627   JAL DRV_TMR1_Initialize
9D0059C8  00000000   NOP
162:                  
163:                  
164:                     /* Initialize System Services */
165:                 
166:                     /*** Interrupt Service Initialization Code ***/
167:                     SYS_INT_Initialize();
9D0059CC  0F401AA8   JAL SYS_INT_Initialize
9D0059D0  00000000   NOP
168:                 
169:                     /* Initialize Middleware */
170:                 
171:                     /* Enable Global Interrupts */
172:                     SYS_INT_Enable();
9D0059D4  40026000   MFC0 V0, Status
9D0059D8  34420001   ORI V0, V0, 1
9D0059DC  40826000   MTC0 V0, Status
9D0059E0  000000C0   EHB
173:                 
174:                     /* Initialize the Application */
175:                     APP_Initialize();
9D0059E4  0F401B16   JAL APP_Initialize
9D0059E8  00000000   NOP
176:                 }
9D0059EC  03C0E821   ADDU SP, FP, ZERO
177:                 
178:                 
179:                 /*******************************************************************************
180:                  End of File
181:                 */
182:                 
---  c:/microchip/harmony/v2_05_01/apps/minf/epreuves/te_frqmtr32bits/firmware/src/system_config/default/system_exceptions.c
1:                   /*******************************************************************************
2:                     MPLAB Harmony Exceptions Source File
3:                   
4:                     File Name:
5:                       system_exceptions.c
6:                   
7:                     Summary:
8:                       This file contains a function which overrides the deafult _weak_ exception
9:                       handler provided by the XC32 compiler.
10:                  
11:                    Description:
12:                      This file redefines the default _weak_  exception handler with a more debug
13:                      friendly one. If an unexpected exception occurs the code will stop in a
14:                      while(1) loop.  The debugger can be halted and two variables _excep_code and
15:                      _except_addr can be examined to determine the cause and address where the
16:                      exception occured.
17:                   *******************************************************************************/
18:                  
19:                  // DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) 2013-2017 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                   *******************************************************************************/
42:                  // DOM-IGNORE-END
43:                  
44:                  
45:                  #include <xc.h>                 /* Defines special function registers, CP0 regs  */
46:                  #include "system_config.h"
47:                  #include "system_definitions.h"
48:                  #include "system/debug/sys_debug.h"
49:                  
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Global Data Definitions
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  /*******************************************************************************
58:                    Exception Reason Data
59:                  
60:                    <editor-fold defaultstate="expanded" desc="Exception Reason Data">
61:                  
62:                    Remarks:
63:                      These global static items are used instead of local variables in the
64:                      _general_exception_handler function because the stack may not be available
65:                      if an exception has occured.
66:                  */
67:                  
68:                  /* Code identifying the cause of the exception (CP0 Cause register). */
69:                  static unsigned int _excep_code;
70:                  
71:                  /* Address of instruction that caused the exception. */
72:                  static unsigned int _excep_addr;
73:                  
74:                  /* Pointer to the string describing the cause of the exception. */
75:                  static char *_cause_str;
76:                  
77:                  /* Array identifying the cause (indexed by _exception_code). */
78:                  static char *cause[] =
79:                  {
80:                      "Interrupt",
81:                      "Undefined",
82:                      "Undefined",
83:                      "Undefined",
84:                      "Load/fetch address error",
85:                      "Store address error",
86:                      "Instruction bus error",
87:                      "Data bus error",
88:                      "Syscall",
89:                      "Breakpoint",
90:                      "Reserved instruction",
91:                      "Coprocessor unusable",
92:                      "Arithmetic overflow",
93:                      "Trap",
94:                      "Reserved",
95:                      "Reserved",
96:                      "Reserved",
97:                      "Reserved",
98:                      "Reserved"
99:                  };
100:                 
101:                 // </editor-fold>
102:                 
103:                 
104:                 // *****************************************************************************
105:                 // *****************************************************************************
106:                 // Section: Exception Handling
107:                 // *****************************************************************************
108:                 // *****************************************************************************
109:                 
110:                 /*******************************************************************************
111:                   Function:
112:                     void _general_exception_handler ( void )
113:                 
114:                   Summary:
115:                     Overrides the XC32 _weak_ _generic_exception_handler.
116:                 
117:                   Description:
118:                     This function overrides the XC32 default _weak_ _generic_exception_handler.
119:                 
120:                   Remarks:
121:                     Refer to the XC32 User's Guide for additional information.
122:                  */
123:                 
124:                 
125:                 void _general_exception_handler ( void )
126:                 {
9D006760  27BDFFF8   ADDIU SP, SP, -8
9D006764  AFBF0004   SW RA, 4(SP)
9D006768  AFBE0000   SW FP, 0(SP)
9D00676C  03A0F021   ADDU FP, SP, ZERO
127:                     /* Mask off Mask of the ExcCode Field from the Cause Register
128:                     Refer to the MIPs Software User's manual */
129:                     _excep_code = (_CP0_GET_CAUSE() & 0x0000007C) >> 2;
9D006770  40026800   MFC0 V0, Cause
9D006774  3042007C   ANDI V0, V0, 124
9D006778  00021082   SRL V0, V0, 2
9D00677C  AF828018   SW V0, -32744(GP)
130:                     _excep_addr = _CP0_GET_EPC();
9D006780  40027000   MFC0 V0, EPC
9D006784  AF82801C   SW V0, -32740(GP)
131:                     _cause_str  = cause[_excep_code];
9D006788  8F838018   LW V1, -32744(GP)
9D00678C  3C02A000   LUI V0, -24576
9D006790  00031880   SLL V1, V1, 2
9D006794  24420034   ADDIU V0, V0, 52
9D006798  00621021   ADDU V0, V1, V0
9D00679C  8C420000   LW V0, 0(V0)
9D0067A0  AF828020   SW V0, -32736(GP)
132:                     SYS_DEBUG_PRINT(SYS_ERROR_FATAL, "\n\rGeneral Exception %s (cause=%d, addr=%x).\n\r",
133:                                     _cause_str, _excep_code, _excep_addr);
134:                 
135:                     while (1)
136:                     {
137:                         SYS_DEBUG_BreakPoint();
138:                     }
9D0067A4  0B4019E9   J 0x9D0067A4
139:                 }
140:                 
141:                 /*******************************************************************************
142:                  End of File
143:                 */
---  c:/microchip/harmony/v2_05_01/apps/minf/epreuves/te_frqmtr32bits/firmware/src/system_config/default/framework/system/ports/src/sys_ports_static.c
1:                   /*******************************************************************************
2:                     SYS PORTS Static Functions for PORTS System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_ports_static.c
9:                   
10:                    Summary:
11:                      SYS PORTS static function implementations for the Ports System Service.
12:                  
13:                    Description:
14:                      The Ports System Service provides a simple interface to manage the ports
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Ports System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system ports configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                  
24:                  *******************************************************************************/
25:                  
26:                  //DOM-IGNORE-BEGIN
27:                  /*******************************************************************************
28:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                  *******************************************************************************/
49:                  //DOM-IGNORE-END
50:                  
51:                  #include "system_config.h"
52:                  #include "system/ports/sys_ports.h"
53:                  #include "peripheral/devcon/plib_devcon.h"
54:                  #include "peripheral/ports/plib_ports.h"
55:                  #include "peripheral/int/plib_int.h"
56:                  
57:                  /******************************************************************************
58:                    Function:
59:                      SYS_PORTS_Initialize(void)
60:                  
61:                    Summary:
62:                      Initializes Ports System Service
63:                  
64:                    Description:
65:                      This function initializes different port pins/channels to the desired state.
66:                      It also remaps the pins to the desired specific function.
67:                  
68:                    Remarks:
69:                      None.
70:                  */
71:                  void SYS_PORTS_Initialize(void)
72:                  {
9D003F0C  27BDFFE8   ADDIU SP, SP, -24
9D003F10  AFBF0014   SW RA, 20(SP)
9D003F14  AFBE0010   SW FP, 16(SP)
9D003F18  03A0F021   ADDU FP, SP, ZERO
73:                  
74:                      /* AN and CN Pins Initialization */
75:                      PLIB_PORTS_AnPinsModeSelect(PORTS_ID_0, SYS_PORT_AD1PCFG, PORTS_PIN_MODE_DIGITAL);
9D003F1C  00002021   ADDU A0, ZERO, ZERO
9D003F20  2405C53C   ADDIU A1, ZERO, -15044
9D003F24  24060001   ADDIU A2, ZERO, 1
9D003F28  0F401B28   JAL PLIB_PORTS_AnPinsModeSelect
9D003F2C  00000000   NOP
76:                      PLIB_PORTS_CnPinsPullUpEnable(PORTS_ID_0, SYS_PORT_CNPUE);
9D003F30  00002021   ADDU A0, ZERO, ZERO
9D003F34  00002821   ADDU A1, ZERO, ZERO
9D003F38  0F401BC5   JAL PLIB_PORTS_CnPinsPullUpEnable
9D003F3C  00000000   NOP
77:                      PLIB_PORTS_CnPinsEnable(PORTS_ID_0, SYS_PORT_CNEN);
9D003F40  00002021   ADDU A0, ZERO, ZERO
9D003F44  00002821   ADDU A1, ZERO, ZERO
9D003F48  0F401BC1   JAL PLIB_PORTS_CnPinsEnable
9D003F4C  00000000   NOP
78:                      PLIB_PORTS_ChangeNoticeEnable(PORTS_ID_0);
9D003F50  00002021   ADDU A0, ZERO, ZERO
9D003F54  0F401BAF   JAL PLIB_PORTS_ChangeNoticeEnable
9D003F58  00000000   NOP
79:                  
80:                      
81:                      /* PORT A Initialization */
82:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_ODC);
9D003F5C  00002021   ADDU A0, ZERO, ZERO
9D003F60  00002821   ADDU A1, ZERO, ZERO
9D003F64  00003021   ADDU A2, ZERO, ZERO
9D003F68  0F401B40   JAL PLIB_PORTS_OpenDrainEnable
9D003F6C  00000000   NOP
83:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_A,  SYS_PORT_A_LAT);
9D003F70  00002021   ADDU A0, ZERO, ZERO
9D003F74  00002821   ADDU A1, ZERO, ZERO
9D003F78  340680C0   ORI A2, ZERO, -32576
9D003F7C  0F401B30   JAL PLIB_PORTS_Write
9D003F80  00000000   NOP
84:                  	PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_A,  SYS_PORT_A_TRIS ^ 0xFFFF);
9D003F84  00002021   ADDU A0, ZERO, ZERO
9D003F88  00002821   ADDU A1, ZERO, ZERO
9D003F8C  340680F3   ORI A2, ZERO, -32525
9D003F90  0F401B38   JAL PLIB_PORTS_DirectionOutputSet
9D003F94  00000000   NOP
85:                      
86:                      /* PORT B Initialization */
87:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_ODC);
9D003F98  00002021   ADDU A0, ZERO, ZERO
9D003F9C  24050001   ADDIU A1, ZERO, 1
9D003FA0  00003021   ADDU A2, ZERO, ZERO
9D003FA4  0F401B40   JAL PLIB_PORTS_OpenDrainEnable
9D003FA8  00000000   NOP
88:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_B,  SYS_PORT_B_LAT);
9D003FAC  00002021   ADDU A0, ZERO, ZERO
9D003FB0  24050001   ADDIU A1, ZERO, 1
9D003FB4  24060400   ADDIU A2, ZERO, 1024
9D003FB8  0F401B30   JAL PLIB_PORTS_Write
9D003FBC  00000000   NOP
89:                  	PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_B,  SYS_PORT_B_TRIS ^ 0xFFFF);
9D003FC0  00002021   ADDU A0, ZERO, ZERO
9D003FC4  24050001   ADDIU A1, ZERO, 1
9D003FC8  24060500   ADDIU A2, ZERO, 1280
9D003FCC  0F401B38   JAL PLIB_PORTS_DirectionOutputSet
9D003FD0  00000000   NOP
90:                      
91:                      /* PORT C Initialization */
92:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_C, SYS_PORT_C_ODC);
9D003FD4  00002021   ADDU A0, ZERO, ZERO
9D003FD8  24050002   ADDIU A1, ZERO, 2
9D003FDC  00003021   ADDU A2, ZERO, ZERO
9D003FE0  0F401B40   JAL PLIB_PORTS_OpenDrainEnable
9D003FE4  00000000   NOP
93:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_C,  SYS_PORT_C_LAT);
9D003FE8  00002021   ADDU A0, ZERO, ZERO
9D003FEC  24050002   ADDIU A1, ZERO, 2
9D003FF0  00003021   ADDU A2, ZERO, ZERO
9D003FF4  0F401B30   JAL PLIB_PORTS_Write
9D003FF8  00000000   NOP
94:                  	PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_C,  SYS_PORT_C_TRIS ^ 0xFFFF);
9D003FFC  00002021   ADDU A0, ZERO, ZERO
9D004000  24050002   ADDIU A1, ZERO, 2
9D004004  24060006   ADDIU A2, ZERO, 6
9D004008  0F401B38   JAL PLIB_PORTS_DirectionOutputSet
9D00400C  00000000   NOP
95:                      
96:                      /* PORT D Initialization */
97:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_D, SYS_PORT_D_ODC);
9D004010  00002021   ADDU A0, ZERO, ZERO
9D004014  24050003   ADDIU A1, ZERO, 3
9D004018  00003021   ADDU A2, ZERO, ZERO
9D00401C  0F401B40   JAL PLIB_PORTS_OpenDrainEnable
9D004020  00000000   NOP
98:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_D,  SYS_PORT_D_LAT);
9D004024  00002021   ADDU A0, ZERO, ZERO
9D004028  24050003   ADDIU A1, ZERO, 3
9D00402C  34068238   ORI A2, ZERO, -32200
9D004030  0F401B30   JAL PLIB_PORTS_Write
9D004034  00000000   NOP
99:                  	PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_D,  SYS_PORT_D_TRIS ^ 0xFFFF);
9D004038  00002021   ADDU A0, ZERO, ZERO
9D00403C  24050003   ADDIU A1, ZERO, 3
9D004040  3406A238   ORI A2, ZERO, -24008
9D004044  0F401B38   JAL PLIB_PORTS_DirectionOutputSet
9D004048  00000000   NOP
100:                     
101:                     /* PORT E Initialization */
102:                     PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_ODC);
9D00404C  00002021   ADDU A0, ZERO, ZERO
9D004050  24050004   ADDIU A1, ZERO, 4
9D004054  00003021   ADDU A2, ZERO, ZERO
9D004058  0F401B40   JAL PLIB_PORTS_OpenDrainEnable
9D00405C  00000000   NOP
103:                     PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_E,  SYS_PORT_E_LAT);
9D004060  00002021   ADDU A0, ZERO, ZERO
9D004064  24050004   ADDIU A1, ZERO, 4
9D004068  240600F7   ADDIU A2, ZERO, 247
9D00406C  0F401B30   JAL PLIB_PORTS_Write
9D004070  00000000   NOP
104:                 	PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_E,  SYS_PORT_E_TRIS ^ 0xFFFF);
9D004074  00002021   ADDU A0, ZERO, ZERO
9D004078  24050004   ADDIU A1, ZERO, 4
9D00407C  240600FF   ADDIU A2, ZERO, 255
9D004080  0F401B38   JAL PLIB_PORTS_DirectionOutputSet
9D004084  00000000   NOP
105:                     
106:                     /* PORT F Initialization */
107:                     PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_F, SYS_PORT_F_ODC);
9D004088  00002021   ADDU A0, ZERO, ZERO
9D00408C  24050005   ADDIU A1, ZERO, 5
9D004090  00003021   ADDU A2, ZERO, ZERO
9D004094  0F401B40   JAL PLIB_PORTS_OpenDrainEnable
9D004098  00000000   NOP
108:                     PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_F,  SYS_PORT_F_LAT);
9D00409C  00002021   ADDU A0, ZERO, ZERO
9D0040A0  24050005   ADDIU A1, ZERO, 5
9D0040A4  24062000   ADDIU A2, ZERO, 8192
9D0040A8  0F401B30   JAL PLIB_PORTS_Write
9D0040AC  00000000   NOP
109:                 	PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_F,  SYS_PORT_F_TRIS ^ 0xFFFF);
9D0040B0  00002021   ADDU A0, ZERO, ZERO
9D0040B4  24050005   ADDIU A1, ZERO, 5
9D0040B8  24062000   ADDIU A2, ZERO, 8192
9D0040BC  0F401B38   JAL PLIB_PORTS_DirectionOutputSet
9D0040C0  00000000   NOP
110:                     
111:                     /* PORT G Initialization */
112:                     PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_G, SYS_PORT_G_ODC);
9D0040C4  00002021   ADDU A0, ZERO, ZERO
9D0040C8  24050006   ADDIU A1, ZERO, 6
9D0040CC  00003021   ADDU A2, ZERO, ZERO
9D0040D0  0F401B40   JAL PLIB_PORTS_OpenDrainEnable
9D0040D4  00000000   NOP
113:                     PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_G,  SYS_PORT_G_LAT);
9D0040D8  00002021   ADDU A0, ZERO, ZERO
9D0040DC  24050006   ADDIU A1, ZERO, 6
9D0040E0  24060002   ADDIU A2, ZERO, 2
9D0040E4  0F401B30   JAL PLIB_PORTS_Write
9D0040E8  00000000   NOP
114:                 	PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_G,  SYS_PORT_G_TRIS ^ 0xFFFF);
9D0040EC  00002021   ADDU A0, ZERO, ZERO
9D0040F0  24050006   ADDIU A1, ZERO, 6
9D0040F4  24060003   ADDIU A2, ZERO, 3
9D0040F8  0F401B38   JAL PLIB_PORTS_DirectionOutputSet
9D0040FC  00000000   NOP
115:                     
116:                 }
9D004100  03C0E821   ADDU SP, FP, ZERO
117:                 
118:                 /******************************************************************************
119:                   Function:
120:                     PORTS_DATA_TYPE SYS_PORTS_Read( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
121:                 
122:                   Summary:
123:                     Reads the data from the I/O port.
124:                 
125:                   Description:
126:                     This function reads the data from the I/O port.
127:                 
128:                   Remarks:
129:                     None.
130:                 */
131:                 
132:                 PORTS_DATA_TYPE SYS_PORTS_Read( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
133:                 {
134:                     return PLIB_PORTS_Read( index, channel );
135:                 }
136:                 
137:                 
138:                 /******************************************************************************
139:                   Function:
140:                     void SYS_PORTS_Write( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
141:                                       		PORTS_DATA_TYPE value )
142:                 
143:                   Summary:
144:                     Writes the data from the I/O port.
145:                 
146:                   Description:
147:                     This function writes the data to the I/O port.
148:                 
149:                   Remarks:
150:                     None.
151:                 */
152:                 
153:                 void SYS_PORTS_Write( PORTS_MODULE_ID index,
154:                                       PORTS_CHANNEL channel,
155:                                       PORTS_DATA_TYPE value )
156:                 {
157:                     PLIB_PORTS_Write( index, channel, value );
158:                 }
159:                 
160:                 /******************************************************************************
161:                   Function:
162:                     PORTS_DATA_TYPE SYS_PORTS_LatchedGet( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
163:                 
164:                   Summary:
165:                     Reads the data driven on the I/O port.
166:                 
167:                   Description:
168:                     This function reads the data driven on the I/O port.
169:                 
170:                   Remarks:
171:                     None.
172:                 */
173:                 
174:                 PORTS_DATA_TYPE SYS_PORTS_LatchedGet( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
175:                 {
176:                     SYS_ASSERT(false, "This API is not supported on this device");
177:                     /* TODO: Call corresponding PLIB API */
178:                     return 0;
179:                 }
180:                 
181:                 /******************************************************************************
182:                   Function:
183:                     void SYS_PORTS_Set( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
184:                 	                         PORTS_DATA_TYPE value,
185:                                          PORTS_DATA_MASK mask )
186:                 
187:                   Summary:
188:                     Sets the selected digital port/latch based on the mask.
189:                 
190:                   Description:
191:                     This function sets the selected digital port/latch relative to the mask.
192:                 
193:                   Remarks:
194:                     None.
195:                 */
196:                 
197:                 void SYS_PORTS_Set( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
198:                                     PORTS_DATA_TYPE value,
199:                                     PORTS_DATA_MASK mask )
200:                 {
201:                     PLIB_PORTS_Set( index, channel, value, mask );
202:                 }
203:                 
204:                 
205:                 /******************************************************************************
206:                   Function:
207:                     void SYS_PORTS_Clear ( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
208:                                            PORTS_DATA_MASK clearMask )
209:                 
210:                   Summary:
211:                     Clears the selected digital port.
212:                 
213:                   Description:
214:                     This function clears the selected digital port.
215:                 
216:                   Remarks:
217:                     None.
218:                 */
219:                 
220:                 void SYS_PORTS_Clear ( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
221:                                            PORTS_DATA_MASK clearMask )
222:                 {
223:                     PLIB_PORTS_Clear ( index, channel, clearMask );
224:                 }
225:                 
226:                 
227:                 /******************************************************************************
228:                   Function:
229:                     void SYS_PORTS_DirectionSelect( PORTS_MODULE_ID index,
230:                 								SYS_PORTS_PIN_DIRECTION pinDir,
231:                 								PORTS_CHANNEL channel,
232:                 								PORTS_DATA_MASK mask )
233:                   Summary:
234:                     Enables the direction for the selected port.
235:                 
236:                   Description:
237:                     This function enables the direction for the selected port.
238:                 
239:                   Remarks:
240:                     None.
241:                 */
242:                 
243:                 void SYS_PORTS_DirectionSelect( PORTS_MODULE_ID index,
244:                                              SYS_PORTS_PIN_DIRECTION pinDir,
245:                                              PORTS_CHANNEL channel,
246:                                              PORTS_DATA_MASK mask )
247:                 {
248:                     if (pinDir == SYS_PORTS_DIRECTION_INPUT)
249:                     {
250:                         PLIB_PORTS_DirectionInputSet(index, channel, mask);
251:                     }
252:                     else
253:                     {
254:                         PLIB_PORTS_DirectionOutputSet(index, channel, mask);
255:                     }
256:                 }
257:                 
258:                 
259:                 /******************************************************************************
260:                   Function:
261:                     PORTS_DATA_MASK SYS_PORTS_DirectionGet( PORTS_MODULE_ID index,
262:                                                             PORTS_CHANNEL channel )
263:                 
264:                   Summary:
265:                     Reads the port direction for the selected port.
266:                 
267:                   Description:
268:                     This function reads the port direction for the selected port.
269:                 
270:                   Remarks:
271:                     None.
272:                 */
273:                 
274:                 PORTS_DATA_MASK SYS_PORTS_DirectionGet( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
275:                 {
276:                     return PLIB_PORTS_DirectionGet( index, channel );
277:                 }
278:                 
279:                 
280:                 /******************************************************************************
281:                   Function:
282:                     void SYS_PORTS_Toggle( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
283:                                            PORTS_DATA_MASK toggleMask )
284:                 
285:                   Summary:
286:                     Toggles the selected digital port pins.
287:                 
288:                   Description:
289:                     This function toggles the selected digital port pins.
290:                 
291:                   Remarks:
292:                     None.
293:                 */
294:                 
295:                 void SYS_PORTS_Toggle( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
296:                                        PORTS_DATA_MASK toggleMask )
297:                 {
298:                     PLIB_PORTS_Toggle( index, channel, toggleMask );
299:                 }
300:                 
301:                 
302:                 /******************************************************************************
303:                   Function:
304:                     void SYS_PORTS_OpenDrainEnable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
305:                                                      PORTS_DATA_MASK mask )
306:                 
307:                   Summary:
308:                     Enables the open drain functionality for the selected port.
309:                 
310:                   Description:
311:                     This function enables the open drain functionality for the selected port.
312:                 
313:                   Remarks:
314:                     None.
315:                 */
316:                 
317:                 void SYS_PORTS_OpenDrainEnable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
318:                                                 PORTS_DATA_MASK mask )
319:                 {
320:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
321:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
322:                     {
323:                         PLIB_PORTS_OpenDrainEnable( index, channel, mask );
324:                     }
325:                 #endif
326:                 }
327:                 
328:                 
329:                 /******************************************************************************
330:                   Function:
331:                     void SYS_PORTS_OpenDrainDisable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
332:                                                      PORTS_DATA_MASK mask )
333:                 
334:                   Summary:
335:                     Disables the open drain functionality for the selected port.
336:                 
337:                   Description:
338:                     This function disables the open drain functionality for the selected port.
339:                 
340:                   Remarks:
341:                     None.
342:                 */
343:                 
344:                 void SYS_PORTS_OpenDrainDisable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
345:                                                  PORTS_DATA_MASK mask )
346:                 {
347:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
348:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
349:                     {
350:                         PLIB_PORTS_OpenDrainDisable( index, channel, mask );
351:                     }
352:                 #endif
353:                 }
354:                 
355:                 // *****************************************************************************
356:                 /* Function:
357:                     PORTS_DATA_TYPE SYS_PORTS_InterruptStatusGet
358:                     ( 
359:                         PORTS_MODULE_ID index, 
360:                         PORTS_CHANNEL channel 
361:                     )
362:                 
363:                   Summary:
364:                     Reads the data from the I/O port.
365:                 	<p><b>Implementation:</b> Dynamic</p>
366:                 
367:                   Description:
368:                     This function reads the data from the I/O port.
369:                 
370:                 */
371:                 
372:                 PORTS_DATA_TYPE SYS_PORTS_InterruptStatusGet
373:                 ( 
374:                     PORTS_MODULE_ID index, 
375:                     PORTS_CHANNEL channel 
376:                 )
377:                 {
378:                     SYS_ASSERT(false, "This API is not supported on this device");
379:                     return 0;
380:                 }
381:                 
382:                 // *****************************************************************************
383:                 // *****************************************************************************
384:                 // Section: SYS Change Notification Pins Routines
385:                 // *****************************************************************************
386:                 // *****************************************************************************
387:                 
388:                 /******************************************************************************
389:                   Function:
390:                     void SYS_PORTS_ChangeNotificationGlobalEnable( PORTS_MODULE_ID index )
391:                 
392:                   Summary:
393:                     Globally enables the change notification.
394:                 
395:                   Description:
396:                     This function globally enables the change notification.
397:                 
398:                   Remarks:
399:                     None.
400:                 */
401:                 
402:                 void SYS_PORTS_ChangeNotificationGlobalEnable( PORTS_MODULE_ID index )
403:                 {
404:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
405:                     if(PLIB_PORTS_ExistsChangeNotice(index))
406:                     {
407:                         PLIB_PORTS_ChangeNoticeEnable( index );
408:                     }
409:                 #endif
410:                 }
411:                 
412:                 /******************************************************************************
413:                   Function:
414:                     void SYS_PORTS_ChangeNotificationGlobalDisable( PORTS_MODULE_ID index )
415:                 
416:                   Summary:
417:                     Globally disables the change notification.
418:                 
419:                   Description:
420:                     This function globally disables the change notification.
421:                 
422:                   Remarks:
423:                     None.
424:                 */
425:                 
426:                 void SYS_PORTS_ChangeNotificationGlobalDisable( PORTS_MODULE_ID index )
427:                 {
428:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
429:                     if(PLIB_PORTS_ExistsChangeNotice(index))
430:                     {
431:                         PLIB_PORTS_ChangeNoticeDisable( index );
432:                     }
433:                 #endif
434:                 }
435:                 
436:                 /******************************************************************************
437:                   Function:
438:                     void SYS_PORTS_GlobalChangeNotificationDisable( PORTS_MODULE_ID index )
439:                 
440:                   Summary:
441:                     Globally disables the change notification for the selected port.
442:                 
443:                   Description:
444:                     This function globally disables the change notification for the selected port.
445:                 
446:                   Remarks:
447:                     None.
448:                 */
449:                 
450:                 void SYS_PORTS_GlobalChangeNotificationDisable( PORTS_MODULE_ID index )
451:                 {
452:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
453:                     if(PLIB_PORTS_ExistsChangeNotice(index))
454:                     {
455:                         PLIB_PORTS_ChangeNoticeDisable( index );
456:                     }
457:                 #endif
458:                 }
459:                 
460:                 
461:                 /******************************************************************************
462:                   Function:
463:                     void SYS_PORTS_ChangeNotificationEnable( PORTS_MODULE_ID index,
464:                                                              PORTS_CHANGE_NOTICE_PIN pinNum,
465:                                                              SYS_PORTS_PULLUP_PULLDOWN_STATUS value )
466:                 
467:                   Summary:
468:                     Enables the change notification for the selected port.
469:                 
470:                   Description:
471:                     This function enables the change notification for the selected port.
472:                 
473:                   Remarks:
474:                     None.
475:                 */
476:                 
477:                 void SYS_PORTS_ChangeNotificationEnable( PORTS_MODULE_ID index,
478:                                                          PORTS_CHANGE_NOTICE_PIN pinNum,
479:                                                          SYS_PORTS_PULLUP_PULLDOWN_STATUS value )
480:                 {
481:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
482:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
483:                     {
484:                         switch(value)
485:                         {
486:                             case SYS_PORTS_PULLUP_DISABLE:
487:                                 PLIB_PORTS_ChangeNoticePullUpDisable(index, pinNum);
488:                                 break;
489:                             case SYS_PORTS_PULLUP_ENABLE:
490:                                 PLIB_PORTS_ChangeNoticePullUpEnable(index, pinNum);
491:                                 break;
492:                         }
493:                     }
494:                 #endif
495:                 
496:                 #if defined(PLIB_PORTS_ExistsPinChangeNotice)
497:                     if(PLIB_PORTS_ExistsPinChangeNotice(index))
498:                     {
499:                         PLIB_PORTS_PinChangeNoticeEnable( index, pinNum );
500:                     }
501:                 #endif
502:                 }
503:                 
504:                 
505:                 /******************************************************************************
506:                   Function:
507:                     void SYS_PORTS_ChangeNotificationDisable( PORTS_MODULE_ID index,
508:                                                               PORTS_CHANGE_NOTICE_PIN pinNum )
509:                 
510:                   Summary:
511:                     Disables the change notification for the selected port.
512:                 
513:                   Description:
514:                     This function disables the change notification for the selected port.
515:                 
516:                   Remarks:
517:                     None.
518:                 */
519:                 
520:                 void SYS_PORTS_ChangeNotificationDisable( PORTS_MODULE_ID index,
521:                                                           PORTS_CHANGE_NOTICE_PIN pinNum )
522:                 {
523:                 #if defined(PLIB_PORTS_ExistsPinChangeNotice)
524:                     if(PLIB_PORTS_ExistsPinChangeNotice(index))
525:                     {
526:                         PLIB_PORTS_PinChangeNoticeDisable( index, pinNum );
527:                     }
528:                 #endif
529:                 }
530:                 
531:                 
532:                 /******************************************************************************
533:                   Function:
534:                     void SYS_PORTS_ChangeNotificationInIdleModeEnable( PORTS_MODULE_ID index )
535:                 
536:                   Summary:
537:                     Enables the change notification for the selected port in Sleep or Idle mode.
538:                 
539:                   Description:
540:                     This function enables the change notification for the selected port in Sleep
541:                     or Idle mode.
542:                 
543:                   Remarks:
544:                     None.
545:                 */
546:                 
547:                 void SYS_PORTS_ChangeNotificationInIdleModeEnable( PORTS_MODULE_ID index )
548:                 {
549:                 #if defined(PLIB_PORTS_ExistsChangeNoticeInIdle)
550:                     if(PLIB_PORTS_ExistsChangeNoticeInIdle(index))
551:                     {
552:                         PLIB_PORTS_ChangeNoticeInIdleEnable( index );
553:                     }
554:                 #endif
555:                 }
556:                 
557:                 
558:                 // *****************************************************************************
559:                 /* Function:
560:                     void SYS_PORTS_ChangeNotificationInIdleModeDisable( PORTS_MODULE_ID index)
561:                 
562:                   Summary:
563:                     Disables the change notification for the selected port in Sleep or Idle mode.
564:                 
565:                   Description:
566:                     This function disables the change notification for the selected port in Sleep
567:                     or Idle mode.
568:                 
569:                   Remarks:
570:                     None.
571:                 */
572:                 
573:                 void SYS_PORTS_ChangeNotificationInIdleModeDisable( PORTS_MODULE_ID index )
574:                 {
575:                 #if defined(PLIB_PORTS_ExistsChangeNoticeInIdle)
576:                     if(PLIB_PORTS_ExistsChangeNoticeInIdle(index))
577:                     {
578:                         PLIB_PORTS_ChangeNoticeInIdleDisable( index );
579:                     }
580:                 #endif
581:                 }
582:                 
583:                 
584:                 // *****************************************************************************
585:                 /* Function:
586:                     void SYS_PORTS_ChangeNotificationPullUpEnable ( PORTS_MODULE_ID         index,
587:                                                                     PORTS_CHANGE_NOTICE_PIN pinNum )
588:                 
589:                   Summary:
590:                     Enables weak pull-up on change notification pin.
591:                 
592:                   Description:
593:                     This function enables weak pull-up on change notification pin.
594:                 
595:                   Remarks:
596:                     None.
597:                 */
598:                 
599:                 void SYS_PORTS_ChangeNotificationPullUpEnable ( PORTS_MODULE_ID         index,
600:                                                                 PORTS_CHANGE_NOTICE_PIN pinNum )
601:                 {
602:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
603:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
604:                     {
605:                         PLIB_PORTS_ChangeNoticePullUpEnable ( index, pinNum );
606:                     }
607:                 #endif
608:                 }
609:                 
610:                 
611:                 // *****************************************************************************
612:                 /* Function:
613:                     void SYS_PORTS_ChangeNotificationPullUpDisable ( PORTS_MODULE_ID         index,
614:                                                                     PORTS_CHANGE_NOTICE_PIN pinNum )
615:                 
616:                   Summary:
617:                     Disables pull-up on input change.
618:                 
619:                   Description:
620:                     This function disables pull-up on input change.
621:                 
622:                   Remarks:
623:                     None.
624:                 */
625:                 
626:                 void SYS_PORTS_ChangeNotificationPullUpDisable ( PORTS_MODULE_ID         index,
627:                                                                 PORTS_CHANGE_NOTICE_PIN pinNum )
628:                 {
629:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
630:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
631:                     {
632:                         PLIB_PORTS_ChangeNoticePullUpDisable ( index, pinNum );
633:                     }
634:                 #endif
635:                 }
636:                 
637:                 
638:                 // *****************************************************************************
639:                 // *****************************************************************************
640:                 // Section: SYS PORT PINS Control Routines
641:                 // *****************************************************************************
642:                 // *****************************************************************************
643:                 
644:                 // *****************************************************************************
645:                 /* Function:
646:                     void SYS_PORTS_PinModeSelect ( PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin,
647:                     								PORTS_PIN_MODE mode)
648:                 
649:                   Summary:
650:                     Enables the selected pin as analog or digital.
651:                 
652:                   Description:
653:                     This function enables the selected pin as analog or digital.
654:                 
655:                  Remarks:
656:                     None.
657:                 */
658:                 
659:                 void SYS_PORTS_PinModeSelect ( PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin,
660:                 								PORTS_PIN_MODE mode)
661:                 {
662:                 #if defined(PLIB_PORTS_ExistsPinMode)
663:                     if(PLIB_PORTS_ExistsPinMode(index))
664:                     {
665:                         PLIB_PORTS_PinModeSelect ( index, pin, mode);
666:                     }
667:                 #endif
668:                 }
669:                 
670:                 
671:                 // *****************************************************************************
672:                 /* Function:
673:                     void SYS_PORTS_PinWrite ( PORTS_MODULE_ID index,
674:                                               PORTS_CHANNEL channel,
675:                                               PORTS_BIT_POS bitPos
676:                                               bool value )
677:                   Summary:
678:                     Writes the selected digital pin.
679:                 
680:                   Description:
681:                     This function writes the selected digital pin.
682:                 
683:                   Remarks:
684:                     None.
685:                 */
686:                 
687:                 void SYS_PORTS_PinWrite ( PORTS_MODULE_ID index,
688:                                           PORTS_CHANNEL channel,
689:                                           PORTS_BIT_POS bitPos,
690:                                           bool value )
691:                 {
692:                     PLIB_PORTS_PinWrite ( index, channel, bitPos, value );
693:                 }
694:                 
695:                 
696:                 // *****************************************************************************
697:                 /* Function:
698:                     bool SYS_PORTS_PinLatchedGet ( PORTS_MODULE_ID index,
699:                                              PORTS_CHANNEL channel,
700:                                              PORTS_BIT_POS bitPos )
701:                 
702:                   Summary:
703:                     Reads the data driven on selected digital pin.
704:                 
705:                   Description:
706:                     This function reads the driven data on selected digital pin.
707:                 
708:                   Remarks:
709:                     None.
710:                 */
711:                 
712:                 bool SYS_PORTS_PinLatchedGet ( PORTS_MODULE_ID index,
713:                                          PORTS_CHANNEL channel,
714:                                          PORTS_BIT_POS bitPos )
715:                 {
716:                     SYS_ASSERT(false, "This API is not supported on this device");
717:                     /* TODO: Call corresponding PLIB API */
718:                     return false;
719:                 }
720:                 
721:                 
722:                 // *****************************************************************************
723:                 /* Function:
724:                     bool SYS_PORTS_PinRead ( PORTS_MODULE_ID index,
725:                                              PORTS_CHANNEL channel,
726:                                              PORTS_BIT_POS bitPos )
727:                 
728:                   Summary:
729:                     Reads the selected digital pin.
730:                 
731:                   Description:
732:                     This function reads the selected digital pin.
733:                 
734:                   Remarks:
735:                     None.
736:                 */
737:                 
738:                 bool SYS_PORTS_PinRead ( PORTS_MODULE_ID index,
739:                                          PORTS_CHANNEL channel,
740:                                          PORTS_BIT_POS bitPos )
741:                 {
742:                     return PLIB_PORTS_PinGet ( index, channel, bitPos );
743:                 }
744:                 
745:                 
746:                 // *****************************************************************************
747:                 /* Function:
748:                     void SYS_PORTS_PinToggle ( PORTS_MODULE_ID index,
749:                                                PORTS_CHANNEL channel,
750:                                                PORTS_BIT_POS bitPos )
751:                 
752:                   Summary:
753:                     Toggles the selected digital pin.
754:                 
755:                   Description:
756:                     This function toggles the selected digital pin.
757:                 
758:                   Remarks:
759:                     None.
760:                 */
761:                 
762:                 void SYS_PORTS_PinToggle ( PORTS_MODULE_ID index,
763:                                            PORTS_CHANNEL channel,
764:                                            PORTS_BIT_POS bitPos )
765:                 {
766:                     PLIB_PORTS_PinToggle ( index, channel, bitPos );
767:                 }
768:                 
769:                 
770:                 // *****************************************************************************
771:                 /* Function:
772:                     void SYS_PORTS_PinSet( PORTS_MODULE_ID index,
773:                                            PORTS_CHANNEL channel,
774:                                            PORTS_BIT_POS bitPos )
775:                 
776:                   Summary:
777:                     Sets the selected digital pin/latch.
778:                 
779:                   Description:
780:                     This function sets the selected digital pin/latch.
781:                 
782:                   Remarks:
783:                     None.
784:                 */
785:                 
786:                 void SYS_PORTS_PinSet( PORTS_MODULE_ID index,
787:                                        PORTS_CHANNEL channel,
788:                                        PORTS_BIT_POS bitPos )
789:                 {
790:                     PLIB_PORTS_PinSet( index, channel, bitPos );
791:                 }
792:                 
793:                 
794:                 // *****************************************************************************
795:                 /* Function:
796:                     void SYS_PORTS_PinClear ( PORTS_MODULE_ID index,
797:                                               PORTS_CHANNEL channel,
798:                                               PORTS_BIT_POS bitPos )
799:                 
800:                   Summary:
801:                     Clears the selected digital pin.
802:                 
803:                   Description:
804:                     This function clears the selected digital pin.
805:                 
806:                   Remarks:
807:                     None.
808:                 */
809:                 
810:                 void SYS_PORTS_PinClear ( PORTS_MODULE_ID index,
811:                                           PORTS_CHANNEL channel,
812:                                           PORTS_BIT_POS bitPos )
813:                 {
814:                     PLIB_PORTS_PinClear ( index, channel, bitPos );
815:                 }
816:                 
817:                 
818:                 // *****************************************************************************
819:                 /* Function:
820:                     void SYS_PORTS_PinDirectionSelect ( PORTS_MODULE_ID index,
821:                                                      SYS_PORTS_PIN_DIRECTION pinDir,
822:                                                      PORTS_CHANNEL channel,
823:                                                      PORTS_BIT_POS bitPos )
824:                   Summary:
825:                     Enables the direction for the selected pin.
826:                 
827:                   Description:
828:                     This function enables the direction for the selected pin.
829:                 
830:                   Remarks:
831:                     None.
832:                 */
833:                 
834:                 void SYS_PORTS_PinDirectionSelect ( PORTS_MODULE_ID index,
835:                                                  SYS_PORTS_PIN_DIRECTION pinDir,
836:                                                  PORTS_CHANNEL channel,
837:                                                  PORTS_BIT_POS bitPos )
838:                 {
839:                     if (pinDir == SYS_PORTS_DIRECTION_OUTPUT)
840:                     {
841:                         PLIB_PORTS_PinDirectionOutputSet(index, channel, bitPos);
842:                     }
843:                     else
844:                     {
845:                         PLIB_PORTS_PinDirectionInputSet(index, channel, bitPos);
846:                     }
847:                 }
848:                 
849:                 
850:                 // *****************************************************************************
851:                 /* Function:
852:                     void SYS_PORTS_PinOpenDrainEnable ( PORTS_MODULE_ID index,
853:                                                         PORTS_CHANNEL channel,
854:                                                         PORTS_BIT_POS bitPos )
855:                 
856:                   Summary:
857:                     Enables the open-drain functionality for the selected pin.
858:                 
859:                   Description:
860:                     This function enables the open-drain functionality for the selected pin.
861:                 
862:                   Remarks:
863:                     None.
864:                 */
865:                 
866:                 void SYS_PORTS_PinOpenDrainEnable ( PORTS_MODULE_ID index,
867:                                                     PORTS_CHANNEL channel,
868:                                                     PORTS_BIT_POS bitPos )
869:                 {
870:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
871:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
872:                     {
873:                         PLIB_PORTS_PinOpenDrainEnable ( index, channel, bitPos );
874:                     }
875:                 #endif
876:                 }
877:                 
878:                 
879:                 // *****************************************************************************
880:                 /* Function:
881:                     void SYS_PORTS_PinOpenDrainDisable ( PORTS_MODULE_ID index,
882:                                                          PORTS_CHANNEL channel,
883:                                                          PORTS_BIT_POS bitPos )
884:                 
885:                   Summary:
886:                     Disables the open-drain functionality for the selected pin.
887:                 
888:                   Description:
889:                     This function disables the open-drain functionality for the selected pin.
890:                 
891:                   Remarks:
892:                     None.
893:                 */
894:                 
895:                 void SYS_PORTS_PinOpenDrainDisable ( PORTS_MODULE_ID index,
896:                                                      PORTS_CHANNEL channel,
897:                                                      PORTS_BIT_POS bitPos )
898:                 {
899:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
900:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
901:                     {
902:                         PLIB_PORTS_PinOpenDrainDisable ( index, channel, bitPos );
903:                     }
904:                 #endif
905:                 }
906:                 
907:                 
908:                 // *****************************************************************************
909:                 /* Function:
910:                     void SYS_PORTS_PinPullUpEnable ( PORTS_MODULE_ID index, 
911:                                                         PORTS_CHANNEL channel,
912:                                                         PORTS_BIT_POS bitPos )
913:                 
914:                   Summary:
915:                     Enables the pull-up functionality for the selected pin.
916:                 	<p><b>Implementation:</b> Dynamic</p>
917:                 
918:                   Description:
919:                     This function enables the pull-up functionality for the selected pin.
920:                 
921:                   Remarks:
922:                     Not all features are available on all devices. Refer to the specific device
923:                     data sheet for availability.
924:                 */
925:                 
926:                 void SYS_PORTS_PinPullUpEnable ( PORTS_MODULE_ID index, 
927:                                                     PORTS_CHANNEL channel,
928:                                                     PORTS_BIT_POS bitPos )
929:                 {
930:                     SYS_ASSERT(false, "This API is not supported on this device");
931:                     return;
932:                 }
933:                 
934:                 
935:                 // *****************************************************************************
936:                 /* Function:
937:                     void SYS_PORTS_PinPullUpDisable ( PORTS_MODULE_ID index, 
938:                                                          PORTS_CHANNEL channel,
939:                                                          PORTS_BIT_POS bitPos )
940:                 
941:                   Summary:
942:                     Disables the pull-up functionality for the selected pin.
943:                 	<p><b>Implementation:</b> Dynamic</p>
944:                 
945:                   Description:
946:                     This function disables the pull-up functionality for the selected pin.
947:                 
948:                   Remarks:
949:                     Not all features are available on all devices. Refer to the specific device
950:                     data sheet for availability.
951:                 */
952:                 
953:                 void SYS_PORTS_PinPullUpDisable ( PORTS_MODULE_ID index, 
954:                                                      PORTS_CHANNEL channel,
955:                                                      PORTS_BIT_POS bitPos )
956:                 {
957:                     SYS_ASSERT(false, "This API is not supported on this device");
958:                     return;
959:                 }
960:                 
961:                 
962:                 // *****************************************************************************
963:                 /* Function:
964:                     void SYS_PORTS_PinPullDownEnable ( PORTS_MODULE_ID index, 
965:                                                         PORTS_CHANNEL channel,
966:                                                         PORTS_BIT_POS bitPos )
967:                 
968:                   Summary:
969:                     Enables the pull-down functionality for the selected pin.
970:                 	<p><b>Implementation:</b> Dynamic</p>
971:                 
972:                   Description:
973:                     This function enables the pull-down functionality for the selected pin.
974:                 
975:                   Remarks:
976:                     Not all features are available on all devices. Refer to the specific device
977:                     data sheet for availability.
978:                 */
979:                 
980:                 void SYS_PORTS_PinPullDownEnable ( PORTS_MODULE_ID index, 
981:                                                     PORTS_CHANNEL channel,
982:                                                     PORTS_BIT_POS bitPos )
983:                 {
984:                     SYS_ASSERT(false, "This API is not supported on this device");
985:                     return;
986:                 }
987:                 
988:                 
989:                 // *****************************************************************************
990:                 /* Function:
991:                     void SYS_PORTS_PinPullDownDisable ( PORTS_MODULE_ID index, 
992:                                                          PORTS_CHANNEL channel,
993:                                                          PORTS_BIT_POS bitPos )
994:                 
995:                   Summary:
996:                     Disables the pull-down functionality for the selected pin.
997:                 	<p><b>Implementation:</b> Dynamic</p>
998:                 
999:                   Description:
1000:                    This function disables the pull-down functionality for the selected pin.
1001:                
1002:                  Remarks:
1003:                    Not all features are available on all devices. Refer to the specific device
1004:                    data sheet for availability.
1005:                */
1006:                
1007:                void SYS_PORTS_PinPullDownDisable ( PORTS_MODULE_ID index, 
1008:                                                     PORTS_CHANNEL channel,
1009:                                                     PORTS_BIT_POS bitPos )
1010:                {
1011:                    SYS_ASSERT(false, "This API is not supported on this device");
1012:                    return;
1013:                }
1014:                                                     
1015:                                                     
1016:                /******************************************************************************
1017:                  Function:
1018:                    void SYS_PORTS_InterruptEnable
1019:                    (
1020:                        PORTS_MODULE_ID index,
1021:                        PORTS_CHANNEL channel,
1022:                        PORTS_BIT_POS bitPos,
1023:                        PORTS_PIN_INTERRUPT_TYPE pinInterruptType
1024:                    )
1025:                
1026:                  Summary:
1027:                    Enables the change notification interrupt for the selected port pin.
1028:                
1029:                  Description:
1030:                    This function enables the change notification interrupt of selected type
1031:                    for the selected port pin.
1032:                
1033:                  Remarks:
1034:                    None.
1035:                */
1036:                void SYS_PORTS_InterruptEnable
1037:                (
1038:                    PORTS_MODULE_ID index,
1039:                    PORTS_CHANNEL channel,
1040:                    PORTS_BIT_POS bitPos,
1041:                    PORTS_PIN_INTERRUPT_TYPE pinInterruptType
1042:                )
1043:                {
1044:                    SYS_ASSERT(false, "This API is not supported on this device");
1045:                    return;
1046:                }
1047:                
1048:                
1049:                // *****************************************************************************
1050:                /* Function:
1051:                    void SYS_PORTS_RemapInput( PORTS_MODULE_ID      index,
1052:                							  PORTS_REMAP_INPUT_FUNCTION function,
1053:                							  PORTS_REMAP_INPUT_PIN      remapPin )
1054:                
1055:                  Summary:
1056:                    Input/Output (I/O) function remapping.
1057:                
1058:                  Description:
1059:                    This function controls the I/O function remapping.
1060:                
1061:                  Precondition:
1062:                    None.
1063:                */	
1064:                void SYS_PORTS_RemapInput( PORTS_MODULE_ID      index,
1065:                						   PORTS_REMAP_INPUT_FUNCTION function,
1066:                						   PORTS_REMAP_INPUT_PIN      remapPin )
1067:                {
1068:                #if defined(PLIB_PORTS_ExistsRemapInput)
1069:                    if(PLIB_PORTS_ExistsRemapInput(index))
1070:                    {
1071:                        PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
1072:                        PLIB_DEVCON_DeviceRegistersUnlock(DEVCON_ID_0, DEVCON_PPS_REGISTERS);
1073:                        PLIB_PORTS_RemapInput( index, function, remapPin);
1074:                    }
1075:                #endif
1076:                }
1077:                
1078:                // *****************************************************************************
1079:                /* Function:
1080:                    void SYS_PORTS_RemapOutput( PORTS_MODULE_ID      index,
1081:                                                      PORTS_REMAP_OUTPUT_FUNCTION function,
1082:                                                      PORTS_REMAP_OUTPUT_PIN      remapPin )
1083:                
1084:                  Summary:
1085:                    Input/Output (I/O) function remapping.
1086:                
1087:                  Description:
1088:                    This function controls the I/O function remapping.
1089:                
1090:                  Precondition:
1091:                    None.
1092:                */
1093:                void SYS_PORTS_RemapOutput( PORTS_MODULE_ID      index,
1094:                						    PORTS_REMAP_OUTPUT_FUNCTION function,
1095:                						    PORTS_REMAP_OUTPUT_PIN      remapPin )
1096:                {
1097:                #if defined(PLIB_PORTS_ExistsRemapOutput)
1098:                    if(PLIB_PORTS_ExistsRemapOutput(index))
1099:                    {
1100:                        PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
1101:                        PLIB_DEVCON_DeviceRegistersUnlock(DEVCON_ID_0, DEVCON_PPS_REGISTERS);
1102:                        PLIB_PORTS_RemapOutput( index, function, remapPin);
1103:                    }
1104:                #endif
1105:                }
1106:                
1107:                /*******************************************************************************
1108:                 End of File
1109:                */
---  c:/microchip/harmony/v2_05_01/apps/minf/epreuves/te_frqmtr32bits/firmware/src/system_config/default/framework/system/devcon/src/sys_devcon_pic32mx.c
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on Microchip microcontrollers. This file Implements the core
16:                      interface routines for the Device Control system service. While building 
17:                      the system service from source, ALWAYS include this file in the build.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "sys_devcon_local.h"
53:                  #include "peripheral/int/plib_int.h"
54:                  #include "peripheral/osc/plib_osc.h"
55:                  #include "peripheral/pcache/plib_pcache.h"
56:                  #include "peripheral/bmx/plib_bmx.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: File Scope or Global Constants
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Variable Definitions
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  //
70:                  #ifndef PLIB_PCACHE_PREFETCH_ENABLE_ALL
71:                  #define PLIB_PCACHE_PREFETCH_ENABLE_ALL 3
72:                  #endif
73:                  
74:                  // *****************************************************************************
75:                  /* Function:
76:                      void SYS_DEVCON_PerformanceConfig( void )
77:                  
78:                    Summary:
79:                      Configures the PFM wait states and prefetch (cache) module for maximum 
80:                      performance.
81:                  
82:                    Description:
83:                      This function configures the PFM wait states and prefetch (cache) module 
84:                      for maximum performance.
85:                  
86:                    Remarks:
87:                      None.
88:                  */
89:                  
90:                  void __attribute__((nomips16)) SYS_DEVCON_PerformanceConfig( unsigned int sysclk )
91:                  {
9D00479C  27BDFFE0   ADDIU SP, SP, -32
9D0047A0  AFBF001C   SW RA, 28(SP)
9D0047A4  AFBE0018   SW FP, 24(SP)
9D0047A8  03A0F021   ADDU FP, SP, ZERO
9D0047AC  AFC40020   SW A0, 32(FP)
92:                      bool int_flag = false;
9D0047B0  A3C00014   SB ZERO, 20(FP)
93:                      register unsigned long tmp = 0;
9D0047B4  0000F821   ADDU RA, ZERO, ZERO
94:                  
95:                      /* Set kseg0 coherency algorithm to "cacheable, non-coherent, write-back, 
96:                       * write-allocate. This is needed for the prefetch buffer */
97:                      asm("mfc0 %0,$16,0" :  "=r"(tmp));
9D0047B8  40028000   MFC0 V0, Config
9D0047BC  0040F821   ADDU RA, V0, ZERO
98:                      tmp = (tmp & ~7) | 3;
9D0047C0  2403FFF8   ADDIU V1, ZERO, -8
9D0047C4  03E31024   AND V0, RA, V1
9D0047C8  345F0003   ORI RA, V0, 3
99:                      asm("mtc0 %0,$16,0" :: "r" (tmp));
9D0047CC  409F8000   MTC0 RA, Config
100:                 
101:                     /* Set the PFM wait states based on the system clock */
102:                     #if defined(PLIB_PCACHE_ExistsWaitState)
103:                     if (PLIB_PCACHE_ExistsWaitState(PCACHE_ID_0))
9D0047D0  3C02BF88   LUI V0, -16504
9D0047D4  0F401BDE   JAL PLIB_PCACHE_ExistsWaitState
9D0047D8  34444000   ORI A0, V0, 16384
9D0047DC  1040002D   BEQ V0, ZERO, .LBE6
9D0047E0  00000000   NOP
104:                     {
105:                         int ws; /* number of wait states */
106:                         if (sysclk <= 30000000)
9D0047E4  8FC30020   LW V1, 32(FP)
9D0047E8  3C0201C9   LUI V0, 457
9D0047EC  3442C381   ORI V0, V0, -15487
9D0047F0  0062102B   SLTU V0, V1, V0
9D0047F4  10400003   BEQ V0, ZERO, 0x9D004804
9D0047F8  00000000   NOP
107:                             ws = 0;
9D0047FC  0B401215   J 0x9D004854
9D004800  AFC00010   SW ZERO, 16(FP)
108:                         else if (sysclk <= 60000000)
9D004804  8FC30020   LW V1, 32(FP)
9D004808  3C020393   LUI V0, 915
9D00480C  34428701   ORI V0, V0, -30975
9D004810  0062102B   SLTU V0, V1, V0
9D004814  10400004   BEQ V0, ZERO, 0x9D004828
9D004818  00000000   NOP
109:                             ws = 1;
9D00481C  24020001   ADDIU V0, ZERO, 1
9D004820  0B401215   J 0x9D004854
9D004824  AFC20010   SW V0, 16(FP)
110:                         else if (sysclk <= 80000000)
9D004828  8FC30020   LW V1, 32(FP)
9D00482C  3C0204C4   LUI V0, 1220
9D004830  3442B401   ORI V0, V0, -19455
9D004834  0062102B   SLTU V0, V1, V0
9D004838  10400004   BEQ V0, ZERO, 0x9D00484C
9D00483C  00000000   NOP
111:                             ws = 2;
9D004840  24020002   ADDIU V0, ZERO, 2
9D004844  0B401215   J 0x9D004854
9D004848  AFC20010   SW V0, 16(FP)
112:                         else
113:                             ws = 3;
9D00484C  24020003   ADDIU V0, ZERO, 3
9D004850  AFC20010   SW V0, 16(FP)
114:                         /* Interrupts must be disabled when changing wait states */
115:                         int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D004854  0F401B50   JAL PLIB_INT_GetStateAndDisable
9D004858  00002021   ADDU A0, ZERO, ZERO
9D00485C  30420001   ANDI V0, V0, 1
9D004860  0002102B   SLTU V0, ZERO, V0
9D004864  A3C20014   SB V0, 20(FP)
116:                 
117:                         PLIB_PCACHE_WaitStateSet(PCACHE_ID_0, ws);
9D004868  8FC20010   LW V0, 16(FP)
9D00486C  3C03BF88   LUI V1, -16504
9D004870  34644000   ORI A0, V1, 16384
9D004874  0F401BA5   JAL PLIB_PCACHE_WaitStateSet
9D004878  00402821   ADDU A1, V0, ZERO
118:                 
119:                         if (int_flag)
9D00487C  93C20014   LBU V0, 20(FP)
9D004880  10400004   BEQ V0, ZERO, .LBE6
9D004884  00000000   NOP
120:                         {
121:                             PLIB_INT_Enable(INT_ID_0);
9D004888  0F401B1F   JAL .LFE676, PLIB_INT_Enable
9D00488C  00002021   ADDU A0, ZERO, ZERO
122:                             int_flag = false;
9D004890  A3C00014   SB ZERO, 20(FP)
123:                         }
124:                     }
125:                     #endif // defined(PLIB_PCACHE_ExistsWaitState)
126:                 
127:                     /* Interrupts must be disabled when enabling the Prefetch Cache Module */
128:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D004894  0F401B50   JAL PLIB_INT_GetStateAndDisable
9D004898  00002021   ADDU A0, ZERO, ZERO
9D00489C  30420001   ANDI V0, V0, 1
9D0048A0  0002102B   SLTU V0, ZERO, V0
9D0048A4  A3C20014   SB V0, 20(FP)
129:                 
130:                     /* Enable Prefetch Cache Module */
131:                     #if defined(PLIB_PCACHE_ExistsPrefetchEnable)
132:                     if (PLIB_PCACHE_ExistsPrefetchEnable(PCACHE_ID_0))
9D0048A8  3C02BF88   LUI V0, -16504
9D0048AC  0F401BE0   JAL PLIB_PCACHE_ExistsPrefetchEnable
9D0048B0  34444000   ORI A0, V0, 16384
9D0048B4  10400005   BEQ V0, ZERO, 0x9D0048CC
9D0048B8  00000000   NOP
133:                     {
134:                         PLIB_PCACHE_PrefetchEnableSet(PCACHE_ID_0, PLIB_PCACHE_PREFETCH_ENABLE_ALL);
9D0048BC  3C02BF88   LUI V0, -16504
9D0048C0  34444000   ORI A0, V0, 16384
9D0048C4  0F401BAA   JAL PLIB_PCACHE_PrefetchEnableSet
9D0048C8  24050003   ADDIU A1, ZERO, 3
135:                     }
136:                     #endif
137:                 
138:                     /* Set the SRAM wait states to zero */
139:                     #if defined (PLIB_BMX_ExistsDataRamWaitState)
140:                     if (PLIB_BMX_ExistsDataRamWaitState(BMX_ID_0))
9D0048CC  3C02BF88   LUI V0, -16504
9D0048D0  0F401BDC   JAL PLIB_BMX_ExistsDataRamWaitState
9D0048D4  34442000   ORI A0, V0, 8192
9D0048D8  10400005   BEQ V0, ZERO, 0x9D0048F0
9D0048DC  00000000   NOP
141:                     {
142:                         PLIB_BMX_DataRamWaitStateSet(BMX_ID_0, PLIB_BMX_DATA_RAM_WAIT_ZERO);
9D0048E0  3C02BF88   LUI V0, -16504
9D0048E4  34442000   ORI A0, V0, 8192
9D0048E8  0F401B82   JAL PLIB_BMX_DataRamWaitStateSet
9D0048EC  00002821   ADDU A1, ZERO, ZERO
143:                     }            
144:                     #endif
145:                     if (int_flag)
9D0048F0  93C20014   LBU V0, 20(FP)
9D0048F4  10400003   BEQ V0, ZERO, 0x9D004904
9D0048F8  00000000   NOP
146:                     {
147:                         PLIB_INT_Enable(INT_ID_0);
9D0048FC  0F401B1F   JAL .LFE676, PLIB_INT_Enable
9D004900  00002021   ADDU A0, ZERO, ZERO
148:                     }
149:                 }
9D004904  03C0E821   ADDU SP, FP, ZERO
150:                 
151:                 /*******************************************************************************
152:                  End of File
153:                 */
154:                 
---  c:/microchip/harmony/v2_05_01/apps/minf/epreuves/te_frqmtr32bits/firmware/src/system_config/default/framework/system/devcon/src/sys_devcon.c
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on PIC32M Microchip microcontrollers. This file Implements 
16:                      the core interface routines for the Device Control system service.  While 
17:                      building the system service from source, ALWAYS include this file in the 
18:                      build for PIC32M devices.
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  //DOM-IGNORE-END
45:                  
46:                  
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  // Section: Included Files
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  
53:                  #include "system/devcon/src/sys_devcon_local.h"
54:                  #include "peripheral/int/plib_int.h"
55:                  #include "peripheral/devcon/plib_devcon.h"
56:                  #include "peripheral/osc/plib_osc.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: File Scope or Global Constants
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Variable Definitions
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  /* System Device Control Instance */
71:                  SYS_DEVCON_OBJECT sysDevconObj;
72:                  
73:                  
74:                  // *****************************************************************************
75:                  // *****************************************************************************
76:                  // Section: SYS DEVCON Module Initialization Routines
77:                  // *****************************************************************************
78:                  // *****************************************************************************
79:                  
80:                  // *****************************************************************************
81:                  /* Function:
82:                      SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX           index,
83:                                                         const SYS_MODULE_INIT * const    init )
84:                  
85:                    Summary:
86:                      Initializes data for the instance of the Device Control module and opens
87:                      the specific module instance.
88:                  
89:                    Description:
90:                      This function initializes the instance of the Device Control module,
91:                      using the specified initialization data. It also initializes any
92:                      internal data structures.
93:                  
94:                    Remarks:
95:                      This routine should only be called once during system initialization
96:                      unless SYS_DEVCON_Deinitialize is first called to deinitialize the device
97:                      instance before reinitializing it. If the system was already initialized
98:                      it safely returns without causing any disturbance.
99:                  */
100:                 
101:                 SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX index,
102:                                                    const SYS_MODULE_INIT * const init )
103:                 {
9D006A64  27BDFFF8   ADDIU SP, SP, -8
9D006A68  AFBE0004   SW FP, 4(SP)
9D006A6C  03A0F021   ADDU FP, SP, ZERO
9D006A70  00801021   ADDU V0, A0, ZERO
9D006A74  AFC5000C   SW A1, 12(FP)
9D006A78  A7C20008   SH V0, 8(FP)
104:                     sysDevconObj.status = SYS_STATUS_READY;
9D006A7C  24020002   ADDIU V0, ZERO, 2
9D006A80  AF828038   SW V0, -32712(GP)
105:                 
106:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
9D006A84  AF808034   SW ZERO, -32716(GP)
107:                 
108:                     return (SYS_MODULE_OBJ)SYS_DEVCON_INDEX_0;
9D006A88  00001021   ADDU V0, ZERO, ZERO
109:                 }
9D006A8C  03C0E821   ADDU SP, FP, ZERO
110:                 
111:                 
112:                 // *****************************************************************************
113:                 /* Function:
114:                     void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ                  object,
115:                                                const SYS_MODULE_INIT * const   init )
116:                 
117:                    Summary:
118:                     Reinitializes and refreshes the hardware for the instance of the Device 
119:                     Control module.
120:                 
121:                    Description:
122:                     This function reinitializes the instance of the Device Control module using 
123:                     the supplied data. It modifies the internal data structure.
124:                 
125:                    Remarks:
126:                     This operation uses the same initialization data structure as the
127:                     SYS_DEVCON_Initialize operation. This operation can be used to change the
128:                     power state of a DEVCON module. This function can be called multiple times
129:                     to reinitialize the module. This operation uses the same initialization
130:                     data structure as the Initialize operation. This operation can also be
131:                     used to refresh the hardware registers as defined by the initialization
132:                     data.
133:                 */
134:                 
135:                 void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ object,
136:                                            const SYS_MODULE_INIT * const init )
137:                 {
138:                     sysDevconObj.status = SYS_STATUS_READY;
139:                 
140:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
141:                 }
142:                 
143:                 
144:                 // *****************************************************************************
145:                 /* Function:
146:                     void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
147:                 
148:                   Summary:
149:                     Deinitializes the specific module instance of the DEVCON module
150:                 
151:                   Description:
152:                     This function deinitializes the specific module instance disabling its operation 
153:                     (and any hardware for driver modules). Resets all of the internal data
154:                     structures and fields for the specified instance to the default settings.
155:                 
156:                   Remarks:
157:                     Once the Initialize operation has been called, the Deinitialize
158:                     operation must be called before the Initialize operation can be called
159:                     again.
160:                 */
161:                 
162:                 void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
163:                 {
164:                     sysDevconObj.status = SYS_STATUS_UNINITIALIZED;
165:                 }
166:                 
167:                 
168:                 // *****************************************************************************
169:                 /* Function:
170:                     SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
171:                 
172:                   Summary:
173:                     Returns status of the specific instance of the Device Control module.
174:                 
175:                   Description:
176:                     This function returns the status of the specific module instance.
177:                 
178:                   Remarks:
179:                     None.
180:                 */
181:                 
182:                 SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
183:                 {
184:                     return sysDevconObj.status; 
185:                 }
186:                 
187:                 
188:                 // *****************************************************************************
189:                 /* Function:
190:                     void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
191:                 
192:                   Summary:
193:                     Maintains the system Device Control state machine.
194:                 
195:                   Description:
196:                     This function is used to maintain the system Device Control internal state machine.
197:                 
198:                   Remarks:
199:                     This function is normally not called directly by an application.  It is
200:                     called by the system's Tasks routine (SYS_Tasks) or by the appropriate raw
201:                     ISR.
202:                 */
203:                 
204:                 void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
205:                 {
206:                     switch (sysDevconObj.state)
207:                     {
208:                         case SYS_DEVCON_STATE_INIT:
209:                         case SYS_DEVCON_STATE_BUSY:
210:                         case SYS_DEVCON_STATE_READY:
211:                         default:
212:                             break;
213:                     }
214:                 }
215:                 
216:                     
217:                 // *****************************************************************************
218:                 // *****************************************************************************
219:                 // Section: SYS DEVCON Client Setup Routines
220:                 // *****************************************************************************
221:                 // *****************************************************************************
222:                 
223:                 // *****************************************************************************
224:                 /* Function:
225:                     void SYS_DEVCON_SystemUnlock( void )
226:                 
227:                   Summary:
228:                     Performs a system unlock sequence by writing to the SYSKEY register.
229:                 
230:                   Description:
231:                     Performs a system unlock sequence by writing to the SYSKEY register. A 
232:                     system unlock sequence is required before performing certain actions such
233:                     as changing a clock frequency or IO unlocking.
234:                 
235:                   Remarks:
236:                     None.
237:                 */
238:                 
239:                 void SYS_DEVCON_SystemUnlock( void )
240:                 {
9D006368  27BDFFE0   ADDIU SP, SP, -32
9D00636C  AFBF001C   SW RA, 28(SP)
9D006370  AFBE0018   SW FP, 24(SP)
9D006374  03A0F021   ADDU FP, SP, ZERO
241:                     bool int_flag = false;
9D006378  A3C00010   SB ZERO, 16(FP)
242:                 
243:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D00637C  00002021   ADDU A0, ZERO, ZERO
9D006380  0F401B50   JAL PLIB_INT_GetStateAndDisable
9D006384  00000000   NOP
9D006388  30420001   ANDI V0, V0, 1
9D00638C  0002102B   SLTU V0, ZERO, V0
9D006390  A3C20010   SB V0, 16(FP)
244:                 
245:                     PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
9D006394  00002021   ADDU A0, ZERO, ZERO
9D006398  0F401AEE   JAL .LFE677, PLIB_DEVCON_SystemUnlock
9D00639C  00000000   NOP
246:                 
247:                     if (int_flag)
9D0063A0  93C20010   LBU V0, 16(FP)
9D0063A4  10400004   BEQ V0, ZERO, 0x9D0063B8
9D0063A8  00000000   NOP
248:                     {
249:                         PLIB_INT_Enable(INT_ID_0);
9D0063AC  00002021   ADDU A0, ZERO, ZERO
9D0063B0  0F401B1F   JAL .LFE676, PLIB_INT_Enable
9D0063B4  00000000   NOP
250:                     }
251:                 }
9D0063B8  03C0E821   ADDU SP, FP, ZERO
252:                 
253:                 
254:                 // *****************************************************************************
255:                 /* Function:
256:                     void SYS_DEVCON_SystemLock( void )
257:                 
258:                   Summary:
259:                     Performs a system lock sequence by writing to the SYSKEY register.
260:                 
261:                   Description:
262:                     Performs a system lock sequence by writing to the SYSKEY register. A 
263:                     system lock sequence is required after performing the action that required
264:                     a system lock sequence.
265:                 
266:                   Remarks:
267:                     None.
268:                 */
269:                 
270:                 void SYS_DEVCON_SystemLock( void )
271:                 {
9D0063D0  27BDFFE0   ADDIU SP, SP, -32
9D0063D4  AFBF001C   SW RA, 28(SP)
9D0063D8  AFBE0018   SW FP, 24(SP)
9D0063DC  03A0F021   ADDU FP, SP, ZERO
272:                     bool int_flag = false;
9D0063E0  A3C00010   SB ZERO, 16(FP)
273:                    
274:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D0063E4  00002021   ADDU A0, ZERO, ZERO
9D0063E8  0F401B50   JAL PLIB_INT_GetStateAndDisable
9D0063EC  00000000   NOP
9D0063F0  30420001   ANDI V0, V0, 1
9D0063F4  0002102B   SLTU V0, ZERO, V0
9D0063F8  A3C20010   SB V0, 16(FP)
275:                 
276:                     PLIB_DEVCON_SystemLock(DEVCON_ID_0);
9D0063FC  00002021   ADDU A0, ZERO, ZERO
9D006400  0F401B64   JAL PLIB_DEVCON_SystemLock
9D006404  00000000   NOP
277:                 
278:                     if (int_flag)
9D006408  93C20010   LBU V0, 16(FP)
9D00640C  10400004   BEQ V0, ZERO, 0x9D006420
9D006410  00000000   NOP
279:                     {
280:                         PLIB_INT_Enable(INT_ID_0);
9D006414  00002021   ADDU A0, ZERO, ZERO
9D006418  0F401B1F   JAL .LFE676, PLIB_INT_Enable
9D00641C  00000000   NOP
281:                     }
282:                 }
9D006420  03C0E821   ADDU SP, FP, ZERO
283:                 
284:                 
285:                 // *****************************************************************************
286:                 /* Function:
287:                     void SYS_DEVCON_JTAGEnable( void )
288:                 
289:                   Summary:
290:                     Enables the JTAG port on the device.
291:                 
292:                   Description:
293:                     Enables the JTAG port on the device.
294:                 
295:                   Remarks:
296:                     None.
297:                 */
298:                 
299:                 void SYS_DEVCON_JTAGEnable( void )
300:                 {
301:                     PLIB_DEVCON_JTAGPortEnable(DEVCON_ID_0);
302:                 }
303:                 
304:                 
305:                 // *****************************************************************************
306:                 /* Function:
307:                     void SYS_DEVCON_JTAGDisable( void )
308:                 
309:                   Summary:
310:                     Disables the JTAG port on the device.
311:                 
312:                   Description:
313:                     Disables the JTAG port on the device.
314:                 
315:                   Remarks:
316:                     None.
317:                 */
318:                 
319:                 void SYS_DEVCON_JTAGDisable( void )
320:                 {
9D006AD4  27BDFFE8   ADDIU SP, SP, -24
9D006AD8  AFBF0014   SW RA, 20(SP)
9D006ADC  AFBE0010   SW FP, 16(SP)
9D006AE0  03A0F021   ADDU FP, SP, ZERO
321:                     PLIB_DEVCON_JTAGPortDisable(DEVCON_ID_0);
9D006AE4  00002021   ADDU A0, ZERO, ZERO
9D006AE8  0F401B5E   JAL PLIB_DEVCON_JTAGPortDisable
9D006AEC  00000000   NOP
322:                 }
9D006AF0  03C0E821   ADDU SP, FP, ZERO
323:                 
324:                 
325:                 // *****************************************************************************
326:                 /* Function:
327:                     void SYS_DEVCON_TraceEnable( void )
328:                 
329:                   Summary:
330:                     Enables the Trace output port on the device.
331:                 
332:                   Description:
333:                     Enables the Trace output port on the device.
334:                 
335:                   Remarks:
336:                     None.
337:                 */
338:                 
339:                 void SYS_DEVCON_TraceEnable( void )
340:                 {
341:                     #if defined PLIB_DEVCON_ExistsTraceOutput
342:                         if(PLIB_DEVCON_ExistsTraceOutput(DEVCON_ID_0))
343:                         {
344:                             PLIB_DEVCON_TraceOutputEnable(DEVCON_ID_0);
345:                         }
346:                     #endif
347:                 }
348:                 
349:                 
350:                 // *****************************************************************************
351:                 /* Function:
352:                     void SYS_DEVCON_TraceDisable( void )
353:                 
354:                   Summary:
355:                     Disables the Trace output port on the device.
356:                 
357:                   Description:
358:                     Disables the Trace output port on the device.
359:                 
360:                   Remarks:
361:                     None.
362:                 */
363:                 
364:                 void SYS_DEVCON_TraceDisable( void )
365:                 {
366:                     #if defined PLIB_DEVCON_ExistsTraceOutput
367:                     if(PLIB_DEVCON_ExistsTraceOutput(DEVCON_ID_0))
368:                     {
369:                         PLIB_DEVCON_TraceOutputDisable(DEVCON_ID_0);
370:                     }
371:                     #endif
372:                 }
373:                 
374:                 
375:                 // *****************************************************************************
376:                 /* Function:
377:                     void SYS_DEVCON_PowerModeEnter(SYS_POWER_MODE pwrMode)
378:                 
379:                   Summary:
380:                     Puts the device in a low-power state.
381:                 
382:                   Description:
383:                     This function puts the device in a low-power state.
384:                 
385:                   Remarks:
386:                     None.
387:                 */
388:                 
389:                 void __attribute__((nomips16)) SYS_DEVCON_PowerModeEnter( SYS_POWER_MODE pwrMode )
390:                 {
391:                     OSC_OPERATION_ON_WAIT op = SYS_POWER_MODE_IDLE;
392:                 
393:                     switch (pwrMode)
394:                     {
395:                         case SYS_POWER_MODE_IDLE:
396:                             op = OSC_ON_WAIT_IDLE;
397:                             break;
398:                         case SYS_POWER_MODE_SLEEP:
399:                             op = OSC_ON_WAIT_SLEEP;
400:                             break;
401:                         default:
402:                             break;
403:                     }
404:                 
405:                     
406:                     #if defined PLIB_OSC_ExistsOnWaitAction
407:                     if(PLIB_OSC_ExistsOnWaitAction(OSC_ID_0))
408:                     {
409:                         SYS_DEVCON_SystemUnlock();
410:                         PLIB_OSC_OnWaitActionSet (OSC_ID_0, op);
411:                         SYS_DEVCON_SystemLock();
412:                     }
413:                     #endif
414:                     asm volatile ( "wait" );
415:                 }
416:                 
417:                 
418:                 /*******************************************************************************
419:                  End of File
420:                 */
421:                 
---  c:/microchip/harmony/v2_05_01/apps/minf/epreuves/te_frqmtr32bits/firmware/src/system_config/default/framework/system/clk/src/sys_clk_pic32mx.c
1:                   /*******************************************************************************
2:                     SYS CLK Static Functions for Clock System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_clk_static.c
9:                   
10:                    Summary:
11:                      SYS CLK static function implementations for the Clock System Service.
12:                  
13:                    Description:
14:                      The Clock System Service provides a simple interface to manage the oscillators
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Clock System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system clock configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                      
24:                      Static single-open interfaces also eliminate the need for the open handle.
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  //DOM-IGNORE-END
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Include Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include "system_config.h"
59:                  #include "system_definitions.h"
60:                  #include "peripheral/osc/plib_osc.h"
61:                  #include "system/devcon/sys_devcon.h"
62:                  
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  // Section: File Scope Functions
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  
69:                  // *****************************************************************************
70:                  /* Function:
71:                      void SYS_CLK_Static_Initialize ( const SYS_CLK_INIT const * clkInit )
72:                  
73:                    Summary:
74:                      Initializes hardware and internal data structure of the System Clock.
75:                  
76:                    Description:
77:                      This function initializes the hardware and internal data structure of System
78:                      Clock Service.
79:                  
80:                    Remarks:
81:                      This is configuration values for the static version of the Clock System Service 
82:                      module is determined by the user via the Microchip Harmony Configurator GUI.
83:                      This template will build a sys_clk_static.h and sys_clk_static.c file with 
84:                      the configuration per the user's choice.
85:                  
86:                      The objective is to eliminate the user's need to be knowledgeable in the function of
87:                      the 'configuration bits' to configure the system oscillators. 
88:                  */
89:                  
90:                  void SYS_CLK_Initialize( const SYS_CLK_INIT const * clkInit )
91:                  {
9D00649C  27BDFFE8   ADDIU SP, SP, -24
9D0064A0  AFBF0014   SW RA, 20(SP)
9D0064A4  AFBE0010   SW FP, 16(SP)
9D0064A8  03A0F021   ADDU FP, SP, ZERO
9D0064AC  AFC40018   SW A0, 24(FP)
92:                      SYS_DEVCON_SystemUnlock ( );
9D0064B0  0F4018DA   JAL SYS_DEVCON_SystemUnlock
9D0064B4  00000000   NOP
93:                      
94:                      PLIB_OSC_FRCDivisorSelect( OSC_ID_0, OSC_FRC_DIV_2);
9D0064B8  00002021   ADDU A0, ZERO, ZERO
9D0064BC  24050001   ADDIU A1, ZERO, 1
9D0064C0  0F401B6A   JAL PLIB_OSC_FRCDivisorSelect
9D0064C4  00000000   NOP
95:                  
96:                  
97:                  
98:                  
99:                      /* Enable Peripheral Bus 1 */
100:                     PLIB_OSC_PBClockDivisorSet (OSC_ID_0, 0, 1 );
9D0064C8  00002021   ADDU A0, ZERO, ZERO
9D0064CC  00002821   ADDU A1, ZERO, ZERO
9D0064D0  24060001   ADDIU A2, ZERO, 1
9D0064D4  0F40193F   JAL .LFE676, PLIB_OSC_PBClockDivisorSet
9D0064D8  00000000   NOP
101:                 
102:                  
103:                 
104:                     SYS_DEVCON_SystemLock ( );
9D0064DC  0F4018F4   JAL SYS_DEVCON_SystemLock
9D0064E0  00000000   NOP
105:                 }
9D0064E4  03C0E821   ADDU SP, FP, ZERO
106:                 
107:                 //******************************************************************************
108:                 /* Function:
109:                     inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
110:                 
111:                   Summary:
112:                     Gets the system clock frequency in Hertz.
113:                 
114:                   Description:
115:                     This function gets the System clock frequency in Hertz.
116:                 
117:                   Precondition:
118:                     None.
119:                 
120:                   Parameters:
121:                     None.
122:                 
123:                   Returns:
124:                     System clock frequency in Hertz.
125:                 
126:                   Example:
127:                     <code>
128:                     uint32_t sysClockHz;
129:                 
130:                     sysClockHz = SYS_CLK_SystemFrequencyGet ( );
131:                     </code>
132:                 
133:                   Remarks:
134:                  */
135:                 
136:                 inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
137:                 {
9D006B90  27BDFFF8   ADDIU SP, SP, -8
9D006B94  AFBE0004   SW FP, 4(SP)
9D006B98  03A0F021   ADDU FP, SP, ZERO
138:                     return SYS_CLK_FREQ;
9D006B9C  3C0204C4   LUI V0, 1220
9D006BA0  3442B400   ORI V0, V0, -19456
139:                 }
9D006BA4  03C0E821   ADDU SP, FP, ZERO
140:                 
141:                 //******************************************************************************
142:                 /* Function:
143:                     inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
144:                 
145:                   Summary:
146:                     Gets the selected clock peripheral bus frequency in Hertz.
147:                 
148:                   Description:
149:                     This function gets the selected peripheral bus clock frequency in Hertz.
150:                 
151:                   Precondition:
152:                     None.
153:                 
154:                   Parameters:
155:                 	peripheralBus - Reference clock bus selection. One of the possible value from
156:                 				CLK_BUSES_PERIPHERAL enum. For devices that do not have multiple
157:                 				clock channels for Reference clock, CLK_BUS_PERIPHERAL_1 should be
158:                 				the selection.
159:                 
160:                   Returns:
161:                     Clock frequency in Hertz.
162:                 
163:                   Example:
164:                     <code>
165:                     unsigned long peripheralClockHz;
166:                 
167:                     peripheralClockHz = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_PERIPHERAL_5 );
168:                     </code>
169:                 
170:                   Remarks:
171:                 	Most of the devices doesn't have multiple Peripheral clock buses. In that case, 
172:                 	pass CLK_USB_PERIPHERAL_1 as the bus number.
173:                  */
174:                 
175:                 inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
176:                 {
177:                     return SYS_CLK_BUS_PERIPHERAL_1;
178:                 }
179:                 
180:                 
181:                 //******************************************************************************
182:                 /* Function:
183:                     inline uint32_t SYS_CLK_ReferenceFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
184:                 
185:                   Summary:
186:                     Gets the selected Reference clock bus frequency in Hertz.
187:                 
188:                   Description:
189:                     This function gets frequency of the selected Reference clock bus in Hertz.
190:                 
191:                   Precondition:
192:                     None.
193:                 
194:                   Parameters:
195:                 	peripheralBus - Reference clock bus selection. One of the possible value from
196:                 				CLK_BUSES_REFERENCE enum. For devices that do not have multiple
197:                 				clock channels for Reference clock, CLK_BUS_REFERENCE_1 should be
198:                 				the selection.
199:                 
200:                   Returns:
201:                     Clock frequency in Hz.
202:                 
203:                   Example:
204:                     <code>
205:                     unsigned long sysClockOutputHz;
206:                 
207:                     sysClockOutputHz = SYS_CLK_ReferenceFrequencyGet ( CLK_BUS_REFERENCE_3 );
208:                     </code>
209:                 
210:                   Remarks:
211:                     None.
212:                  */
213:                 
214:                 inline uint32_t SYS_CLK_ReferenceFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
215:                 {
216:                 	return 0;
217:                 }
218:                 
219:                 /******************************************************************************
220:                   Function:
221:                     void SYS_CLK_SecondaryOscillatorEnable ( void )
222:                 
223:                   Summary:
224:                     Enables the secondary oscillator.
225:                 
226:                   Description:
227:                     This function enables the secondary oscillator.
228:                 
229:                   Remarks:
230:                     For more details refer sys_clk.h.
231:                 */
232:                 
233:                 void SYS_CLK_SecondaryOscillatorEnable ( void )
234:                 {
235:                     /* Check for secondary oscillator status */
236:                     if (!PLIB_OSC_SecondaryIsEnabled(OSC_ID_0))
237:                     {    
238:                         /* Unlock and enable secondary oscillator */
239:                         SYS_DEVCON_SystemUnlock();
240:                         
241:                         PLIB_OSC_SecondaryEnable(OSC_ID_0);
242:                         
243:                         SYS_DEVCON_SystemLock();
244:                     }
245:                 }
246:                 
247:                 /******************************************************************************
248:                   Function:
249:                     void SYS_CLK_SecondaryOscillatorDisable ( void )
250:                 
251:                   Summary:
252:                     Disables the secondary oscillator.
253:                 
254:                   Description:
255:                     This function disables the secondary oscillator.
256:                 
257:                   Remarks:
258:                     For more details refer sys_clk.h.
259:                 */
260:                 
261:                 void SYS_CLK_SecondaryOscillatorDisable ( void )
262:                 {
263:                     /* Check for secondary oscillator status */
264:                     if (PLIB_OSC_SecondaryIsEnabled(OSC_ID_0))
265:                     {    
266:                         /* Unlock and disable secondary oscillator*/
267:                         SYS_DEVCON_SystemUnlock();
268:                         
269:                         PLIB_OSC_SecondaryDisable(OSC_ID_0);
270:                         
271:                         SYS_DEVCON_SystemLock();
272:                     }
273:                 }
274:                 
275:                 /******************************************************************************
276:                   Function:
277:                     bool SYS_CLK_SecondaryOscillatorIsEnabled ( void )
278:                 
279:                   Summary:
280:                     Identifies whether secondary oscillator is enabled or disabled.
281:                 
282:                   Description:
283:                     This function identifies whether the secondary oscillator is enabled or 
284:                     disabled.
285:                     
286:                   Remarks:
287:                     For more details refer sys_clk.h.
288:                 */
289:                 
290:                 bool SYS_CLK_SecondaryOscillatorIsEnabled ( void )
291:                 {
292:                     return (PLIB_OSC_SecondaryIsEnabled(OSC_ID_0));
293:                 }
---  c:/microchip/harmony/v2_05_01/apps/minf/epreuves/te_frqmtr32bits/firmware/src/system_config/default/framework/driver/tmr/src/drv_tmr_static.c
1:                   /*******************************************************************************
2:                     Timer Static Driver File
3:                   
4:                     File Name:
5:                       drv_tmr_static.c
6:                   
7:                     Company:
8:                       Microchip Technology Inc.   
9:                   
10:                    Summary:
11:                      Timer driver implementation for the static single instance driver.
12:                  
13:                    Description:
14:                      The Timer device driver provides a simple interface to manage the Timer
15:                      modules on Microchip microcontrollers.
16:                      
17:                    Remarks:
18:                      None
19:                   *******************************************************************************/
20:                  
21:                  /*******************************************************************************
22:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublTMRense terms in the accompanying lTMRense agreement).
28:                  
29:                  You should refer to the lTMRense agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTTMRULAR PURPOSE.
35:                  IN NO EVENT SHALL MTMRROCHIP OR ITS LTMRENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRTMRT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVTMRES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                   *******************************************************************************/
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Header Includes
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  #include "driver/tmr/drv_tmr_static.h"
50:                  #include "driver/tmr/src/drv_tmr_variant_mapping.h"
51:                  
52:                  typedef struct
53:                  {
54:                      DRV_TMR_CALLBACK alarmFunc;  // For alarm registering
55:                      uint32_t alarmCount;    // For AlarmHasElapsed function
56:                      bool    alarmEnabled;   // For Enable/Disable function
57:                      bool    alarmPeriodic;      // Keep Alarm enabled or disable it
58:                      uintptr_t   alarmContext;   // For Alarm Callback
59:                      uint32_t    alarmPeriod;    // For Period Set/Get
60:                  } DRV_TMR_ALARM_OBJ;
61:                  
62:                  static bool _DRV_TMR_ClockSourceSet(TMR_MODULE_ID timerId, DRV_TMR_CLK_SOURCES clockSource)
63:                  {
64:                      bool clockSet = true;
65:                      /* Clock Source Selection */
66:                      if(clockSource == DRV_TMR_CLKSOURCE_INTERNAL)
67:                      {
68:                          if ( PLIB_TMR_ExistsClockSource ( timerId ) )
69:                          {               
70:                              PLIB_TMR_ClockSourceSelect ( timerId, TMR_CLOCK_SOURCE_PERIPHERAL_CLOCK );           
71:                          }
72:                          else
73:                          {
74:                              /* If clock source feature doesn't exist for any specific timer module instance,
75:                              then by default internal peripheral clock is considered as timer source, so do nothing */ 
76:                          }
77:                      }
78:                      /* External Synchronous Clock Source Selection */
79:                      else if(!(clockSource & 0x10))
80:                      {
81:                          if ( PLIB_TMR_ExistsClockSource ( timerId ) )
82:                          {               
83:                              if ( PLIB_TMR_ExistsClockSourceSync ( timerId )  )
84:                              {
85:                                  PLIB_TMR_ClockSourceSelect ( timerId, (TMR_CLOCK_SOURCE)(clockSource & 0x0F) );                
86:                                  PLIB_TMR_ClockSourceExternalSyncEnable ( timerId );                    
87:                              }
88:                              /* If Synchronization feature doesn't exist for any specific timer module 
89:                              instance with external clock source then it is synchronous by default */
90:                              else if (clockSource == DRV_TMR_CLKSOURCE_EXTERNAL_SYNCHRONOUS)
91:                              {
92:                                  PLIB_TMR_ClockSourceSelect ( timerId, TMR_CLOCK_SOURCE_EXTERNAL_INPUT_PIN );
93:                              }
94:                              else
95:                              {
96:                                  clockSet = false;
97:                              }  
98:                          }
99:                          else
100:                         {
101:                             clockSet = false;
102:                         }        
103:                     }
104:                     /* External Asynchronous Clock Source Selection */
105:                     else if(clockSource & 0x10)
106:                     {
107:                         if ( PLIB_TMR_ExistsClockSourceSync ( timerId ) )
108:                         {
109:                             PLIB_TMR_ClockSourceSelect ( timerId, (TMR_CLOCK_SOURCE)(clockSource & 0x0F) );
110:                             PLIB_TMR_ClockSourceExternalSyncDisable ( timerId );
111:                         }
112:                         else
113:                         {
114:                             clockSet = false;
115:                         }        
116:                     }
117:                     
118:                     return clockSet;
119:                 }
120:                 
121:                 // Prescaler selection
122:                 static bool _DRV_TMR_ClockPrescaleSet(TMR_MODULE_ID timerId, TMR_PRESCALE  prescale)
123:                 {
124:                     if( PLIB_TMR_ExistsPrescale( timerId ) )
125:                     {
126:                         PLIB_TMR_PrescaleSelect( timerId , prescale );
127:                         return true;
128:                     }
129:                     return false;
130:                 }
131:                 
132:                 
133:                 // *****************************************************************************
134:                 // *****************************************************************************
135:                 // Section: Instance 0 static driver data
136:                 // *****************************************************************************
137:                 // *****************************************************************************
138:                 
139:                 static bool                   DRV_TMR0_Running;
140:                 
141:                 // *****************************************************************************
142:                 // *****************************************************************************
143:                 // Section: Instance 0 static driver functions
144:                 // *****************************************************************************
145:                 // *****************************************************************************
146:                 void DRV_TMR0_Initialize(void)
147:                 {   
9D0057E0  27BDFFE8   ADDIU SP, SP, -24
9D0057E4  AFBF0014   SW RA, 20(SP)
9D0057E8  AFBE0010   SW FP, 16(SP)
9D0057EC  03A0F021   ADDU FP, SP, ZERO
148:                     /* Initialize Timer Instance0 */
149:                     /* Disable Timer */
150:                     PLIB_TMR_Stop(TMR_ID_1);
9D0057F0  3C02BF80   LUI V0, -16512
9D0057F4  34440600   ORI A0, V0, 1536
9D0057F8  0F401BCD   JAL PLIB_TMR_Stop
9D0057FC  00000000   NOP
151:                     /* Select clock source */
152:                     PLIB_TMR_ClockSourceSelect ( TMR_ID_1, TMR_CLOCK_SOURCE_PERIPHERAL_CLOCK );
9D005800  3C02BF80   LUI V0, -16512
9D005804  34440600   ORI A0, V0, 1536
9D005808  00002821   ADDU A1, ZERO, ZERO
9D00580C  0F401BB4   JAL PLIB_TMR_ClockSourceSelect
9D005810  00000000   NOP
153:                     /* Select prescalar value */
154:                     PLIB_TMR_PrescaleSelect(TMR_ID_1, TMR_PRESCALE_VALUE_64);
9D005814  3C02BF80   LUI V0, -16512
9D005818  34440600   ORI A0, V0, 1536
9D00581C  24050006   ADDIU A1, ZERO, 6
9D005820  0F401681   JAL .LFE676, PLIB_TMR_PrescaleSelect
9D005824  00000000   NOP
155:                     /* Enable 16 bit mode */
156:                     PLIB_TMR_Mode16BitEnable(TMR_ID_1);
9D005828  3C02BF80   LUI V0, -16512
9D00582C  34440600   ORI A0, V0, 1536
9D005830  0F401B70   JAL PLIB_TMR_Mode16BitEnable
9D005834  00000000   NOP
157:                     /* Clear counter */ 
158:                     PLIB_TMR_Counter16BitClear(TMR_ID_1);
9D005838  3C02BF80   LUI V0, -16512
9D00583C  34440600   ORI A0, V0, 1536
9D005840  0F401BD4   JAL PLIB_TMR_Counter16BitClear
9D005844  00000000   NOP
159:                     /*Set period */ 
160:                     PLIB_TMR_Period16BitSet(TMR_ID_1, 62499);
9D005848  3C02BF80   LUI V0, -16512
9D00584C  34440600   ORI A0, V0, 1536
9D005850  3405F423   ORI A1, ZERO, -3037
9D005854  0F401BD7   JAL PLIB_TMR_Period16BitSet
9D005858  00000000   NOP
161:                     /* Setup Interrupt */   
162:                     PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_T1, INT_PRIORITY_LEVEL1);
9D00585C  00002021   ADDU A0, ZERO, ZERO
9D005860  24050004   ADDIU A1, ZERO, 4
9D005864  24060001   ADDIU A2, ZERO, 1
9D005868  0F40199A   JAL PLIB_INT_VectorPrioritySet
9D00586C  00000000   NOP
163:                     PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_T1, INT_SUBPRIORITY_LEVEL0);          
9D005870  00002021   ADDU A0, ZERO, ZERO
9D005874  24050004   ADDIU A1, ZERO, 4
9D005878  00003021   ADDU A2, ZERO, ZERO
9D00587C  0F4019C4   JAL .LFE0, PLIB_INT_VectorSubPrioritySet
9D005880  00000000   NOP
164:                 }
9D005884  03C0E821   ADDU SP, FP, ZERO
165:                 
166:                 static void _DRV_TMR0_Resume(bool resume)
167:                 {
9D0061C0  27BDFFE8   ADDIU SP, SP, -24
9D0061C4  AFBF0014   SW RA, 20(SP)
9D0061C8  AFBE0010   SW FP, 16(SP)
9D0061CC  03A0F021   ADDU FP, SP, ZERO
9D0061D0  00801021   ADDU V0, A0, ZERO
9D0061D4  A3C20018   SB V0, 24(FP)
168:                     if (resume)
9D0061D8  93C20018   LBU V0, 24(FP)
9D0061DC  1040000D   BEQ V0, ZERO, 0x9D006214
9D0061E0  00000000   NOP
169:                     {
170:                         PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_1);
9D0061E4  00002021   ADDU A0, ZERO, ZERO
9D0061E8  24050004   ADDIU A1, ZERO, 4
9D0061EC  0F401AF8   JAL PLIB_INT_SourceFlagClear
9D0061F0  00000000   NOP
171:                         PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_TIMER_1);
9D0061F4  00002021   ADDU A0, ZERO, ZERO
9D0061F8  24050004   ADDIU A1, ZERO, 4
9D0061FC  0F401B02   JAL PLIB_INT_SourceEnable
9D006200  00000000   NOP
172:                         PLIB_TMR_Start(TMR_ID_1);
9D006204  3C02BF80   LUI V0, -16512
9D006208  34440600   ORI A0, V0, 1536
9D00620C  0F401BC9   JAL PLIB_TMR_Start
9D006210  00000000   NOP
173:                     }
174:                 }
9D006214  03C0E821   ADDU SP, FP, ZERO
175:                 
176:                 bool DRV_TMR0_Start(void)
177:                 {
9D0069E4  27BDFFE8   ADDIU SP, SP, -24
9D0069E8  AFBF0014   SW RA, 20(SP)
9D0069EC  AFBE0010   SW FP, 16(SP)
9D0069F0  03A0F021   ADDU FP, SP, ZERO
178:                     /* Start Timer*/
179:                     _DRV_TMR0_Resume(true);
9D0069F4  24040001   ADDIU A0, ZERO, 1
9D0069F8  0F401870   JAL .LFE279, .LFB679, _DRV_TMR0_Resume
9D0069FC  00000000   NOP
180:                     DRV_TMR0_Running = true;
9D006A00  24020001   ADDIU V0, ZERO, 1
9D006A04  A3828014   SB V0, -32748(GP)
181:                     
182:                     return true;
9D006A08  24020001   ADDIU V0, ZERO, 1
183:                 }
9D006A0C  03C0E821   ADDU SP, FP, ZERO
184:                 
185:                 static bool _DRV_TMR0_Suspend(void)
186:                 {
187:                     if (DRV_TMR0_Running)
188:                     {
189:                         PLIB_INT_SourceDisable(INT_ID_0, INT_SOURCE_TIMER_1);
190:                         PLIB_TMR_Stop(TMR_ID_1);
191:                         return (true);
192:                     }
193:                     
194:                     return (false);
195:                 }
196:                 
197:                 void DRV_TMR0_Stop(void)
198:                 {
199:                     _DRV_TMR0_Suspend();
200:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_1);
201:                     DRV_TMR0_Running = false;
202:                 }
203:                 
204:                 DRV_TMR_CLIENT_STATUS DRV_TMR0_ClientStatus ( void )
205:                 {
206:                     if (DRV_TMR0_Running)
207:                         return DRV_TMR_CLIENT_STATUS_RUNNING;
208:                     else
209:                         return DRV_TMR_CLIENT_STATUS_READY;
210:                 }
211:                 
212:                 void DRV_TMR0_CounterValueSet(uint32_t value)
213:                 {
214:                     /* Set 16-bit counter value*/
215:                     PLIB_TMR_Counter16BitSet(TMR_ID_1, (uint16_t)value);
216:                 }
217:                 
218:                 uint32_t DRV_TMR0_CounterValueGet(void)
219:                 {
220:                     /* Get 16-bit counter value*/
221:                     return (uint32_t) PLIB_TMR_Counter16BitGet(TMR_ID_1);
222:                 }
223:                 
224:                 void DRV_TMR0_CounterClear(void)
225:                 {
226:                     /* Clear 16-bit counter value*/
227:                     PLIB_TMR_Counter16BitClear(TMR_ID_1);
228:                 }
229:                 
230:                 DRV_TMR_OPERATION_MODE DRV_TMR0_DividerRangeGet
231:                 (
232:                 	DRV_TMR_DIVIDER_RANGE * pDivRange
233:                 )
234:                 {
235:                 	if(pDivRange)
236:                 	{
237:                         pDivRange->dividerMax = DRV_TIMER_DIVIDER_MAX_16BIT;
238:                         pDivRange->dividerMin = DRV_TIMER_DIVIDER_MIN_16BIT;
239:                 		pDivRange->dividerStep = 1;
240:                 		return DRV_TMR_OPERATION_MODE_16_BIT;
241:                 	}
242:                 	return DRV_TMR_OPERATION_MODE_NONE;
243:                 }
244:                 
245:                 uint32_t DRV_TMR0_CounterFrequencyGet(void)
246:                 {
247:                     uint32_t prescale, tmrBaseFreq;
248:                     
249:                     tmrBaseFreq = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_FOR_TIMER_PERIPHERAL );
250:                     prescale = PLIB_TMR_PrescaleGet(TMR_ID_1);
251:                     return ( tmrBaseFreq / prescale );
252:                 }
253:                 
254:                 TMR_PRESCALE DRV_TMR0_PrescalerGet(void)
255:                 {
256:                     uint16_t prescale_value;
257:                     /* Call the PLIB directly */
258:                     prescale_value = PLIB_TMR_PrescaleGet(TMR_ID_1);
259:                     
260:                     switch(prescale_value)
261:                     {
262:                         case 1: return TMR_PRESCALE_VALUE_1;
263:                         case 2: return TMR_PRESCALE_VALUE_2;
264:                         case 4: return TMR_PRESCALE_VALUE_4;
265:                         case 8: return TMR_PRESCALE_VALUE_8;
266:                         case 16: return TMR_PRESCALE_VALUE_16;
267:                         case 32: return TMR_PRESCALE_VALUE_32;
268:                         case 64: return TMR_PRESCALE_VALUE_64;
269:                         case 256: return TMR_PRESCALE_VALUE_256;
270:                         default: return TMR_PRESCALE_VALUE_1;
271:                     }
272:                 }
273:                 
274:                 void DRV_TMR0_PeriodValueSet(uint32_t value)
275:                 {
276:                     /* Set 16-bit counter value*/
277:                     PLIB_TMR_Period16BitSet(TMR_ID_1, (uint16_t)value);
278:                 }
279:                 
280:                 uint32_t DRV_TMR0_PeriodValueGet(void)
281:                 {
282:                     /* Get 16-bit counter value*/
283:                     return (uint32_t) PLIB_TMR_Period16BitGet(TMR_ID_1);
284:                 }
285:                 
286:                 void DRV_TMR0_StopInIdleDisable(void)
287:                 {
288:                     PLIB_TMR_StopInIdleDisable(TMR_ID_1);
289:                 }
290:                 
291:                 void DRV_TMR0_StopInIdleEnable(void)
292:                 {
293:                     PLIB_TMR_StopInIdleDisable(TMR_ID_1);
294:                 }
295:                 
296:                 bool DRV_TMR0_ClockSet
297:                 (
298:                     DRV_TMR_CLK_SOURCES clockSource,
299:                     TMR_PRESCALE        preScale
300:                 )
301:                 {
302:                     bool success = false;
303:                     bool resume = _DRV_TMR0_Suspend();
304:                     
305:                     if (_DRV_TMR_ClockSourceSet(TMR_ID_1, clockSource) &&
306:                         _DRV_TMR_ClockPrescaleSet(TMR_ID_1, preScale))
307:                     {
308:                         success = true;
309:                     }
310:                     
311:                     _DRV_TMR0_Resume(resume);
312:                     return success;
313:                 }
314:                 
315:                 // *****************************************************************************
316:                 // *****************************************************************************
317:                 // Section: Instance 1 static driver data
318:                 // *****************************************************************************
319:                 // *****************************************************************************
320:                 
321:                 static bool                   DRV_TMR1_Running;
322:                 
323:                 // *****************************************************************************
324:                 // *****************************************************************************
325:                 // Section: Instance 1 static driver functions
326:                 // *****************************************************************************
327:                 // *****************************************************************************
328:                 void DRV_TMR1_Initialize(void)
329:                 {   
9D00589C  27BDFFE8   ADDIU SP, SP, -24
9D0058A0  AFBF0014   SW RA, 20(SP)
9D0058A4  AFBE0010   SW FP, 16(SP)
9D0058A8  03A0F021   ADDU FP, SP, ZERO
330:                     /* Initialize Timer Instance1 */
331:                     /* Disable Timer */
332:                     PLIB_TMR_Stop(TMR_ID_2);
9D0058AC  3C02BF80   LUI V0, -16512
9D0058B0  34440800   ORI A0, V0, 2048
9D0058B4  0F401BCD   JAL PLIB_TMR_Stop
9D0058B8  00000000   NOP
333:                     /* Select clock source */
334:                     PLIB_TMR_ClockSourceSelect ( TMR_ID_2, TMR_CLOCK_SOURCE_PERIPHERAL_CLOCK );
9D0058BC  3C02BF80   LUI V0, -16512
9D0058C0  34440800   ORI A0, V0, 2048
9D0058C4  00002821   ADDU A1, ZERO, ZERO
9D0058C8  0F401BB4   JAL PLIB_TMR_ClockSourceSelect
9D0058CC  00000000   NOP
335:                     /* Select prescalar value */
336:                     PLIB_TMR_PrescaleSelect(TMR_ID_2, TMR_PRESCALE_VALUE_1);
9D0058D0  3C02BF80   LUI V0, -16512
9D0058D4  34440800   ORI A0, V0, 2048
9D0058D8  00002821   ADDU A1, ZERO, ZERO
9D0058DC  0F401681   JAL .LFE676, PLIB_TMR_PrescaleSelect
9D0058E0  00000000   NOP
337:                     /* Enable 32 bit mode */
338:                     PLIB_TMR_Mode32BitEnable(TMR_ID_2);
9D0058E4  3C02BF80   LUI V0, -16512
9D0058E8  34440800   ORI A0, V0, 2048
9D0058EC  0F401B76   JAL PLIB_TMR_Mode32BitEnable
9D0058F0  00000000   NOP
339:                     /* Clear counter */
340:                     PLIB_TMR_Counter32BitClear(TMR_ID_2);
9D0058F4  3C02BF80   LUI V0, -16512
9D0058F8  34440800   ORI A0, V0, 2048
9D0058FC  0F401B57   JAL PLIB_TMR_Counter32BitClear
9D005900  00000000   NOP
341:                     /*Set period */ 
342:                     PLIB_TMR_Period32BitSet(TMR_ID_2, 4294967295UL);
9D005904  3C02BF80   LUI V0, -16512
9D005908  34440800   ORI A0, V0, 2048
9D00590C  2405FFFF   ADDIU A1, ZERO, -1
9D005910  0F401B48   JAL PLIB_TMR_Period32BitSet
9D005914  00000000   NOP
343:                     /* Setup Interrupt */   
344:                     PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_T3, INT_DISABLE_INTERRUPT);
9D005918  00002021   ADDU A0, ZERO, ZERO
9D00591C  2405000C   ADDIU A1, ZERO, 12
9D005920  00003021   ADDU A2, ZERO, ZERO
9D005924  0F40199A   JAL PLIB_INT_VectorPrioritySet
9D005928  00000000   NOP
345:                     PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_T3, INT_SUBPRIORITY_LEVEL0);          
9D00592C  00002021   ADDU A0, ZERO, ZERO
9D005930  2405000C   ADDIU A1, ZERO, 12
9D005934  00003021   ADDU A2, ZERO, ZERO
9D005938  0F4019C4   JAL .LFE0, PLIB_INT_VectorSubPrioritySet
9D00593C  00000000   NOP
346:                 }
9D005940  03C0E821   ADDU SP, FP, ZERO
347:                 
348:                 static void _DRV_TMR1_Resume(bool resume)
349:                 {
9D00622C  27BDFFE8   ADDIU SP, SP, -24
9D006230  AFBF0014   SW RA, 20(SP)
9D006234  AFBE0010   SW FP, 16(SP)
9D006238  03A0F021   ADDU FP, SP, ZERO
9D00623C  00801021   ADDU V0, A0, ZERO
9D006240  A3C20018   SB V0, 24(FP)
350:                     if (resume)
9D006244  93C20018   LBU V0, 24(FP)
9D006248  1040000D   BEQ V0, ZERO, 0x9D006280
9D00624C  00000000   NOP
351:                     {
352:                         PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_3);
9D006250  00002021   ADDU A0, ZERO, ZERO
9D006254  2405000C   ADDIU A1, ZERO, 12
9D006258  0F401AF8   JAL PLIB_INT_SourceFlagClear
9D00625C  00000000   NOP
353:                         PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_TIMER_3);
9D006260  00002021   ADDU A0, ZERO, ZERO
9D006264  2405000C   ADDIU A1, ZERO, 12
9D006268  0F401B02   JAL PLIB_INT_SourceEnable
9D00626C  00000000   NOP
354:                         PLIB_TMR_Start(TMR_ID_2);
9D006270  3C02BF80   LUI V0, -16512
9D006274  34440800   ORI A0, V0, 2048
9D006278  0F401BC9   JAL PLIB_TMR_Start
9D00627C  00000000   NOP
355:                     }
356:                 }
9D006280  03C0E821   ADDU SP, FP, ZERO
357:                 
358:                 bool DRV_TMR1_Start(void)
359:                 {
9D006A24  27BDFFE8   ADDIU SP, SP, -24
9D006A28  AFBF0014   SW RA, 20(SP)
9D006A2C  AFBE0010   SW FP, 16(SP)
9D006A30  03A0F021   ADDU FP, SP, ZERO
360:                     /* Start Timer*/
361:                     _DRV_TMR1_Resume(true);
9D006A34  24040001   ADDIU A0, ZERO, 1
9D006A38  0F40188B   JAL .LFB696, _DRV_TMR1_Resume, .LFE679
9D006A3C  00000000   NOP
362:                     DRV_TMR1_Running = true;
9D006A40  24020001   ADDIU V0, ZERO, 1
9D006A44  A3828015   SB V0, -32747(GP)
363:                     
364:                     return true;
9D006A48  24020001   ADDIU V0, ZERO, 1
365:                 }
9D006A4C  03C0E821   ADDU SP, FP, ZERO
366:                 
367:                 static bool _DRV_TMR1_Suspend(void)
368:                 {
369:                     if (DRV_TMR1_Running)
370:                     {
371:                         PLIB_INT_SourceDisable(INT_ID_0, INT_SOURCE_TIMER_3);
372:                         PLIB_TMR_Stop(TMR_ID_2);
373:                         return (true);
374:                     }
375:                     
376:                     return (false);
377:                 }
378:                 
379:                 void DRV_TMR1_Stop(void)
380:                 {
381:                     _DRV_TMR1_Suspend();
382:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_3);
383:                     DRV_TMR1_Running = false;
384:                 }
385:                 
386:                 DRV_TMR_CLIENT_STATUS DRV_TMR1_ClientStatus ( void )
387:                 {
388:                     if (DRV_TMR1_Running)
389:                         return DRV_TMR_CLIENT_STATUS_RUNNING;
390:                     else
391:                         return DRV_TMR_CLIENT_STATUS_READY;
392:                 }
393:                 
394:                 void DRV_TMR1_CounterValueSet(uint32_t value)
395:                 {
396:                     /* Set 32-bit counter value*/
397:                     PLIB_TMR_Counter32BitSet(TMR_ID_2, value);
398:                 }
399:                 
400:                 uint32_t DRV_TMR1_CounterValueGet(void)
401:                 {
402:                     /* Get 32-bit counter value*/
403:                     return PLIB_TMR_Counter32BitGet(TMR_ID_2);
404:                 }
405:                 
406:                 void DRV_TMR1_CounterClear(void)
407:                 {
408:                     /* Clear 32-bit counter value*/
409:                     PLIB_TMR_Counter32BitClear(TMR_ID_2);
410:                 }
411:                 
412:                 DRV_TMR_OPERATION_MODE DRV_TMR1_DividerRangeGet
413:                 (
414:                 	DRV_TMR_DIVIDER_RANGE * pDivRange
415:                 )
416:                 {
417:                 	if(pDivRange)
418:                 	{
419:                         pDivRange->dividerMax = DRV_TIMER_DIVIDER_MAX_32BIT;
420:                         pDivRange->dividerMin = DRV_TIMER_DIVIDER_MIN_32BIT;
421:                 		pDivRange->dividerStep = 1;
422:                 		return DRV_TMR_OPERATION_MODE_32_BIT;
423:                 	}
424:                 	return DRV_TMR_OPERATION_MODE_NONE;
425:                 }
426:                 
427:                 uint32_t DRV_TMR1_CounterFrequencyGet(void)
428:                 {
429:                     uint32_t prescale, tmrBaseFreq;
430:                     
431:                     tmrBaseFreq = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_FOR_TIMER_PERIPHERAL );
432:                     prescale = PLIB_TMR_PrescaleGet(TMR_ID_2);
433:                     return ( tmrBaseFreq / prescale );
434:                 }
435:                 
436:                 TMR_PRESCALE DRV_TMR1_PrescalerGet(void)
437:                 {
438:                     uint16_t prescale_value;
439:                     /* Call the PLIB directly */
440:                     prescale_value = PLIB_TMR_PrescaleGet(TMR_ID_2);
441:                     
442:                     switch(prescale_value)
443:                     {
444:                         case 1: return TMR_PRESCALE_VALUE_1;
445:                         case 2: return TMR_PRESCALE_VALUE_2;
446:                         case 4: return TMR_PRESCALE_VALUE_4;
447:                         case 8: return TMR_PRESCALE_VALUE_8;
448:                         case 16: return TMR_PRESCALE_VALUE_16;
449:                         case 32: return TMR_PRESCALE_VALUE_32;
450:                         case 64: return TMR_PRESCALE_VALUE_64;
451:                         case 256: return TMR_PRESCALE_VALUE_256;
452:                         default: return TMR_PRESCALE_VALUE_1;
453:                     }
454:                 }
455:                 
456:                 void DRV_TMR1_PeriodValueSet(uint32_t value)
457:                 {
458:                     /* Set 32-bit counter value*/
459:                     PLIB_TMR_Period32BitSet(TMR_ID_2, value);
460:                 }
461:                 
462:                 uint32_t DRV_TMR1_PeriodValueGet(void)
463:                 {
464:                     /* Get 32-bit counter value*/
465:                     return PLIB_TMR_Period32BitGet(TMR_ID_2);
466:                 }
467:                 
468:                 void DRV_TMR1_StopInIdleDisable(void)
469:                 {
470:                     PLIB_TMR_StopInIdleDisable(TMR_ID_2);
471:                 }
472:                 
473:                 void DRV_TMR1_StopInIdleEnable(void)
474:                 {
475:                     PLIB_TMR_StopInIdleDisable(TMR_ID_2);
476:                 }
477:                 
478:                 bool DRV_TMR1_ClockSet
479:                 (
480:                     DRV_TMR_CLK_SOURCES clockSource,
481:                     TMR_PRESCALE        preScale
482:                 )
483:                 {
484:                     bool success = false;
485:                     bool resume = _DRV_TMR1_Suspend();
486:                     
487:                     if (_DRV_TMR_ClockSourceSet(TMR_ID_2, clockSource) &&
488:                         _DRV_TMR_ClockPrescaleSet(TMR_ID_2, preScale))
489:                     {
490:                         success = true;
491:                     }
492:                     
493:                     _DRV_TMR1_Resume(resume);
494:                     return success;
495:                 }
496:                 
497:                  
498:                  
499:                 /*******************************************************************************
500:                  End of File
501:                 */
---  c:/microchip/harmony/v2_05_01/apps/minf/epreuves/te_frqmtr32bits/firmware/src/system_config/default/framework/driver/ic/src/drv_ic_static.c
1:                   /*******************************************************************************
2:                     IC Driver Functions for Static Single Instance Driver
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_ic_static.c
9:                   
10:                    Summary:
11:                      IC driver implementation for the static single instance driver.
12:                  
13:                    Description:
14:                      The IC device driver provides a simple interface to manage the IC
15:                      modules on Microchip microcontrollers.
16:                      
17:                    Remarks:
18:                      Static interfaces incorporate the driver instance number within the names
19:                      of the routines, eliminating the need for an object ID or object handle.
20:                      Static single-open interfaces also eliminate the need for the open handle.
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  //DOM-IGNORE-END
47:                  
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  // Header Includes
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  #include "peripheral/ic/plib_ic.h"
54:                  #include "peripheral/int/plib_int.h"
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Instance 0 static driver functions
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  void DRV_IC0_Initialize(void)
62:                  {	
9D0055A0  27BDFFE8   ADDIU SP, SP, -24
9D0055A4  AFBF0014   SW RA, 20(SP)
9D0055A8  AFBE0010   SW FP, 16(SP)
9D0055AC  03A0F021   ADDU FP, SP, ZERO
63:                      PLIB_IC_ModeSelect(IC_ID_5, IC_INPUT_CAPTURE_RISING_EDGE_MODE);
9D0055B0  3C02BF80   LUI V0, -16512
9D0055B4  34442800   ORI A0, V0, 10240
9D0055B8  24050003   ADDIU A1, ZERO, 3
9D0055BC  0F401B91   JAL PLIB_IC_ModeSelect
9D0055C0  00000000   NOP
64:                      PLIB_IC_FirstCaptureEdgeSelect(IC_ID_5, IC_EDGE_RISING);
9D0055C4  3C02BF80   LUI V0, -16512
9D0055C8  34442800   ORI A0, V0, 10240
9D0055CC  24050001   ADDIU A1, ZERO, 1
9D0055D0  0F401B87   JAL PLIB_IC_FirstCaptureEdgeSelect
9D0055D4  00000000   NOP
65:                      PLIB_IC_TimerSelect(IC_ID_5, IC_TIMER_TMR2);
9D0055D8  3C02BF80   LUI V0, -16512
9D0055DC  34442800   ORI A0, V0, 10240
9D0055E0  24050001   ADDIU A1, ZERO, 1
9D0055E4  0F401B9B   JAL PLIB_IC_TimerSelect
9D0055E8  00000000   NOP
66:                      PLIB_IC_BufferSizeSelect(IC_ID_5, IC_BUFFER_SIZE_32BIT);
9D0055EC  3C02BF80   LUI V0, -16512
9D0055F0  34442800   ORI A0, V0, 10240
9D0055F4  24050001   ADDIU A1, ZERO, 1
9D0055F8  0F401B96   JAL PLIB_IC_BufferSizeSelect
9D0055FC  00000000   NOP
67:                      PLIB_IC_EventsPerInterruptSelect(IC_ID_5, IC_INTERRUPT_ON_EVERY_CAPTURE_EVENT);   
9D005600  3C02BF80   LUI V0, -16512
9D005604  34442800   ORI A0, V0, 10240
9D005608  00002821   ADDU A1, ZERO, ZERO
9D00560C  0F401B8C   JAL PLIB_IC_EventsPerInterruptSelect
9D005610  00000000   NOP
68:                  
69:                      /* Setup Interrupt */   
70:                      PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_INPUT_CAPTURE_5);
9D005614  00002021   ADDU A0, ZERO, ZERO
9D005618  24050015   ADDIU A1, ZERO, 21
9D00561C  0F401B02   JAL PLIB_INT_SourceEnable
9D005620  00000000   NOP
71:                      PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_IC5, INT_PRIORITY_LEVEL7);
9D005624  00002021   ADDU A0, ZERO, ZERO
9D005628  24050015   ADDIU A1, ZERO, 21
9D00562C  24060007   ADDIU A2, ZERO, 7
9D005630  0F40199A   JAL PLIB_INT_VectorPrioritySet
9D005634  00000000   NOP
72:                      PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_IC5, INT_SUBPRIORITY_LEVEL0);          
9D005638  00002021   ADDU A0, ZERO, ZERO
9D00563C  24050015   ADDIU A1, ZERO, 21
9D005640  00003021   ADDU A2, ZERO, ZERO
9D005644  0F4019C4   JAL .LFE0, PLIB_INT_VectorSubPrioritySet
9D005648  00000000   NOP
73:                  }
9D00564C  03C0E821   ADDU SP, FP, ZERO
74:                  
75:                  void DRV_IC0_Start(void)
76:                  {
9D0060E4  27BDFFE8   ADDIU SP, SP, -24
9D0060E8  AFBF0014   SW RA, 20(SP)
9D0060EC  AFBE0010   SW FP, 16(SP)
9D0060F0  03A0F021   ADDU FP, SP, ZERO
77:                      //ajout SCA purge du buffer
78:                      while(!PLIB_IC_BufferIsEmpty(IC_ID_5))
9D0060F4  0B401843   J 0x9D00610C
9D0060F8  00000000   NOP
9D00610C  3C02BF80   LUI V0, -16512
9D006110  34442800   ORI A0, V0, 10240
9D006114  0F401BBD   JAL PLIB_IC_BufferIsEmpty
9D006118  00000000   NOP
9D00611C  38420001   XORI V0, V0, 1
9D006120  304200FF   ANDI V0, V0, 255
9D006124  1440FFF5   BNE V0, ZERO, 0x9D0060FC
9D006128  00000000   NOP
79:                          PLIB_IC_Buffer32BitGet(IC_ID_5);
9D0060FC  3C02BF80   LUI V0, -16512
9D006100  34442800   ORI A0, V0, 10240
9D006104  0F401BD1   JAL PLIB_IC_Buffer32BitGet
9D006108  00000000   NOP
80:                          
81:                     PLIB_IC_Enable(IC_ID_5);
9D00612C  3C02BF80   LUI V0, -16512
9D006130  34442800   ORI A0, V0, 10240
9D006134  0F401BB9   JAL PLIB_IC_Enable
9D006138  00000000   NOP
82:                  }
9D00613C  03C0E821   ADDU SP, FP, ZERO
83:                  
84:                  void DRV_IC0_Stop(void)
85:                  {
86:                     PLIB_IC_Disable(IC_ID_5);
87:                  }
88:                  
89:                  void DRV_IC0_Open(void)
90:                  {
91:                  }
92:                  
93:                  void DRV_IC0_Close(void)
94:                  {
95:                  }
96:                  uint32_t DRV_IC0_Capture32BitDataRead(void)
97:                  {
98:                     return PLIB_IC_Buffer32BitGet(IC_ID_5);
99:                  }
100:                 
101:                 uint16_t DRV_IC0_Capture16BitDataRead(void)
102:                 {
103:                    return PLIB_IC_Buffer16BitGet(IC_ID_5);
104:                 }
105:                 
106:                 bool DRV_IC0_BufferIsEmpty(void)
107:                 {
108:                    return PLIB_IC_BufferIsEmpty(IC_ID_5);
109:                 }
110:                 
111:                 /*******************************************************************************
112:                  End of File
113:                 */
---  c:/microchip/harmony/v2_05_01/apps/minf/epreuves/te_frqmtr32bits/firmware/src/main.c  --------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Project Main Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       main.c
9:                   
10:                    Summary:
11:                      This file contains the "main" function for an MPLAB Harmony project.
12:                  
13:                    Description:
14:                      This file contains the "main" function for an MPLAB Harmony project.  The
15:                      "main" function calls the "SYS_Initialize" function to initialize the state 
16:                      machines of all MPLAB Harmony modules in the system and it calls the 
17:                      "SYS_Tasks" function from within a system-wide "super" loop to maintain 
18:                      their correct operation. These two functions are implemented in 
19:                      configuration-specific files (usually "system_init.c" and "system_tasks.c")
20:                      in a configuration-specific folder under the "src/system_config" folder 
21:                      within this project's top-level folder.  An MPLAB Harmony project may have
22:                      more than one configuration, each contained within it's own folder under
23:                      the "system_config" folder.
24:                   *******************************************************************************/
25:                  
26:                  // DOM-IGNORE-BEGIN
27:                  /*******************************************************************************
28:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  //Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                   *******************************************************************************/
49:                  // DOM-IGNORE-END
50:                  
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Included Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include <stddef.h>                     // Defines NULL
59:                  #include <stdbool.h>                    // Defines true
60:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
61:                  #include "system/common/sys_module.h"   // SYS function prototypes
62:                  
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Main Entry Point
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  int main ( void )
71:                  {
9D006B64  27BDFFE8   ADDIU SP, SP, -24
9D006B68  AFBF0014   SW RA, 20(SP)
9D006B6C  AFBE0010   SW FP, 16(SP)
9D006B70  03A0F021   ADDU FP, SP, ZERO
72:                      /* Initialize all MPLAB Harmony modules, including application(s). */
73:                      SYS_Initialize ( NULL );
9D006B74  00002021   ADDU A0, ZERO, ZERO
9D006B78  0F401656   JAL SYS_Initialize
9D006B7C  00000000   NOP
74:                  
75:                  
76:                      while ( true )
77:                      {
78:                          /* Maintain state machines of all polled MPLAB Harmony modules. */
79:                          SYS_Tasks ( );
9D006B80  0F401AC2   JAL SYS_Tasks
9D006B84  00000000   NOP
80:                  
81:                      }
9D006B88  0B401AE0   J 0x9D006B80
82:                  
83:                      /* Execution should not come here during normal operation */
84:                  
85:                      return ( EXIT_FAILURE );
86:                  }
87:                  
88:                  
89:                  /*******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/microchip/harmony/v2_05_01/apps/minf/epreuves/te_frqmtr32bits/firmware/src/app.c  ---------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       app.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "app.h"
57:                  #include "Mc32DriverLcd.h"
58:                  
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  // Section: Global Data Definitions
62:                  // *****************************************************************************
63:                  // *****************************************************************************
64:                  
65:                  // *****************************************************************************
66:                  /* Application Data
67:                  
68:                    Summary:
69:                      Holds application data
70:                  
71:                    Description:
72:                      This structure holds the application's data.
73:                  
74:                    Remarks:
75:                      This structure should be initialized by the APP_Initialize function.
76:                      
77:                      Application strings and buffers are be defined outside this structure.
78:                  */
79:                  
80:                  APP_DATA appData;
81:                  uint32_t capturedValues[2];
82:                  bool newValue;
83:                  
84:                  // *****************************************************************************
85:                  // *****************************************************************************
86:                  // Section: Application Callback Functions
87:                  // *****************************************************************************
88:                  // *****************************************************************************
89:                  
90:                  /* TODO:  Add any necessary callback functions.
91:                  */
92:                  
93:                  // *****************************************************************************
94:                  // *****************************************************************************
95:                  // Section: Application Local Functions
96:                  // *****************************************************************************
97:                  // *****************************************************************************
98:                  
99:                  
100:                 /* TODO:  Add any necessary local functions.
101:                 */
102:                 
103:                 
104:                 // *****************************************************************************
105:                 // *****************************************************************************
106:                 // Section: Application Initialization and State Machine Functions
107:                 // *****************************************************************************
108:                 // *****************************************************************************
109:                 
110:                 /*******************************************************************************
111:                   Function:
112:                     void APP_Initialize ( void )
113:                 
114:                   Remarks:
115:                     See prototype in app.h.
116:                  */
117:                 
118:                 void APP_Initialize ( void )
119:                 {
9D006C58  27BDFFF8   ADDIU SP, SP, -8
9D006C5C  AFBE0004   SW FP, 4(SP)
9D006C60  03A0F021   ADDU FP, SP, ZERO
120:                     /* Place the App state machine in its initial state. */
121:                     appData.state = APP_STATE_INIT;
9D006C64  AF808030   SW ZERO, -32720(GP)
122:                 
123:                     
124:                     /* TODO: Initialize your application's state machine and other
125:                      * parameters.
126:                      */
127:                 }
9D006C68  03C0E821   ADDU SP, FP, ZERO
128:                 
129:                 
130:                 /******************************************************************************
131:                   Function:
132:                     void APP_Tasks ( void )
133:                 
134:                   Remarks:
135:                     See prototype in app.h.
136:                  */
137:                 
138:                 void APP_Tasks ( void )
139:                 {
9D003640  27BDFFD8   ADDIU SP, SP, -40
9D003644  AFBF0024   SW RA, 36(SP)
9D003648  AFBE0020   SW FP, 32(SP)
9D00364C  03A0F021   ADDU FP, SP, ZERO
140:                     uint32_t period32;
141:                     float freq;
142:                     
143:                     /* Check the application's current state. */
144:                     switch ( appData.state )
9D003650  8F828030   LW V0, -32720(GP)
9D003654  24030001   ADDIU V1, ZERO, 1
9D003658  10430082   BEQ V0, V1, 0x9D003864
9D00365C  00000000   NOP
9D003660  2C430001   SLTIU V1, V0, 1
9D003664  14600006   BNE V1, ZERO, .LBB2
9D003668  00000000   NOP
9D00366C  24030002   ADDIU V1, ZERO, 2
9D003670  1043001F   BEQ V0, V1, .LBE2
9D003674  00000000   NOP
145:                     {
146:                         /* Application's initial state. */
147:                         case APP_STATE_INIT:
148:                         {
149:                             bool appInitialized = true;
9D003680  24020001   ADDIU V0, ZERO, 1
9D003684  A3C20018   SB V0, 24(FP)
150:                             
151:                             capturedValues[0] = 0;
9D003688  AF808024   SW ZERO, -32732(GP)
152:                             capturedValues[1] = 0;
9D00368C  AF808028   SW ZERO, -32728(GP)
153:                             newValue = false;        
9D003690  A380802C   SB ZERO, -32724(GP)
154:                             
155:                             //init affichage
156:                             lcd_init();
9D003694  0F4012EF   JAL lcd_init
9D003698  00000000   NOP
157:                             printf_lcd("TE2 MINF / SCA");
9D00369C  3C029D00   LUI V0, -25344
9D0036A0  244467F8   ADDIU A0, V0, 26616
9D0036A4  0F401855   JAL printf_lcd
9D0036A8  00000000   NOP
158:                             lcd_bl_on();
9D0036AC  0F401A46   JAL lcd_bl_on
9D0036B0  00000000   NOP
159:                             
160:                             DRV_TMR0_Start();
9D0036B4  0F401A79   JAL DRV_TMR0_Start
9D0036B8  00000000   NOP
161:                             DRV_TMR1_Start();
9D0036BC  0F401A89   JAL DRV_TMR1_Start
9D0036C0  00000000   NOP
162:                             DRV_IC0_Start();
9D0036C4  0F401839   JAL DRV_IC0_Start
9D0036C8  00000000   NOP
163:                         
164:                             if (appInitialized)
9D0036CC  93C20018   LBU V0, 24(FP)
9D0036D0  10400005   BEQ V0, ZERO, 0x9D0036E8
9D0036D4  00000000   NOP
165:                             {
166:                             
167:                                 appData.state = APP_STATE_WAIT;
9D0036D8  24020001   ADDIU V0, ZERO, 1
9D0036DC  AF828030   SW V0, -32720(GP)
168:                             }
169:                             break;
9D0036E0  0B400E1A   J 0x9D003868
9D0036E4  00000000   NOP
9D0036E8  0B400E1A   J 0x9D003868
9D0036EC  00000000   NOP
170:                         }
171:                 
172:                         case APP_STATE_WAIT:
173:                             break;
9D003864  00000000   NOP
174:                             
175:                         case APP_STATE_SERVICE_TASKS:
176:                         {
177:                             if(newValue)
9D0036F0  9382802C   LBU V0, -32724(GP)
9D0036F4  10400057   BEQ V0, ZERO, .LBE3
9D0036F8  00000000   NOP
178:                             {
179:                                 uint32_t unit = 0;
9D0036FC  AFC00014   SW ZERO, 20(FP)
180:                                 
181:                                 LED3_W = 1;
9D003700  3C03BF88   LUI V1, -16504
9D003704  94626020   LHU V0, 24608(V1)
9D003708  24040001   ADDIU A0, ZERO, 1
9D00370C  7C822944   INS V0, A0, 5, 1
9D003710  A4626020   SH V0, 24608(V1)
182:                                 
183:                                 newValue = false;
9D003714  A380802C   SB ZERO, -32724(GP)
184:                                 //pas d'interruption IC pendant la soustraction...
185:                                 PLIB_INT_SourceDisable(INT_ID_0, INT_SOURCE_INPUT_CAPTURE_5);
9D003718  00002021   ADDU A0, ZERO, ZERO
9D00371C  24050015   ADDIU A1, ZERO, 21
9D003720  0F401B0C   JAL PLIB_INT_SourceDisable
9D003724  00000000   NOP
186:                                 period32 = capturedValues[0]-capturedValues[1];
9D003728  8F838024   LW V1, -32732(GP)
9D00372C  8F828028   LW V0, -32728(GP)
9D003730  00621023   SUBU V0, V1, V0
9D003734  AFC2001C   SW V0, 28(FP)
187:                                 PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_INPUT_CAPTURE_5);
9D003738  00002021   ADDU A0, ZERO, ZERO
9D00373C  24050015   ADDIU A1, ZERO, 21
9D003740  0F401B02   JAL PLIB_INT_SourceEnable
9D003744  00000000   NOP
188:                                 freq = 80000000.0 / period32;
9D003748  8FC4001C   LW A0, 28(FP)
9D00374C  0F4019EB   JAL __floatunsisf
9D003750  00000000   NOP
9D003754  3C039D00   LUI V1, -25344
9D003758  8C646838   LW A0, 26680(V1)
9D00375C  00402821   ADDU A1, V0, ZERO
9D003760  0F400EAF   JAL __divsf3
9D003764  00000000   NOP
9D003768  AFC20010   SW V0, 16(FP)
189:                                 while(freq >= 1000.0)
9D00376C  0B400DE6   J 0x9D003798
9D003770  00000000   NOP
9D003798  3C029D00   LUI V0, -25344
9D00379C  8C44683C   LW A0, 26684(V0)
9D0037A0  8FC50010   LW A1, 16(FP)
9D0037A4  0F401701   JAL __ltsf2
9D0037A8  00000000   NOP
9D0037AC  1840FFF1   BLEZ V0, 0x9D003774
9D0037B0  00000000   NOP
190:                                 {
191:                                     unit++;
9D003774  8FC20014   LW V0, 20(FP)
9D003778  24420001   ADDIU V0, V0, 1
9D00377C  AFC20014   SW V0, 20(FP)
192:                                     freq /= 1000.0;
9D003780  3C029D00   LUI V0, -25344
9D003784  8FC40010   LW A0, 16(FP)
9D003788  8C45683C   LW A1, 26684(V0)
9D00378C  0F400EAF   JAL __divsf3
9D003790  00000000   NOP
9D003794  AFC20010   SW V0, 16(FP)
193:                                 }
194:                                 
195:                                 lcd_gotoxy(1,2);
9D0037B4  24040001   ADDIU A0, ZERO, 1
9D0037B8  24050002   ADDIU A1, ZERO, 2
9D0037BC  0F4017B9   JAL lcd_gotoxy
9D0037C0  00000000   NOP
196:                                 switch (unit)
9D0037C4  8FC20014   LW V0, 20(FP)
9D0037C8  24030001   ADDIU V1, ZERO, 1
9D0037CC  10430010   BEQ V0, V1, 0x9D003810
9D0037D0  00000000   NOP
9D0037D4  2C430001   SLTIU V1, V0, 1
9D0037D8  14600006   BNE V1, ZERO, 0x9D0037F4
9D0037DC  00000000   NOP
9D0037E0  24030002   ADDIU V1, ZERO, 2
9D0037E4  10430011   BEQ V0, V1, 0x9D00382C
9D0037E8  00000000   NOP
9D0037EC  0B400E11   J 0x9D003844
9D0037F0  00000000   NOP
197:                                 {
198:                                     case 0:
199:                                         printf_lcd("%.3f  [Hz]  ", freq);    
9D0037F4  3C029D00   LUI V0, -25344
9D0037F8  24446808   ADDIU A0, V0, 26632
9D0037FC  8FC50010   LW A1, 16(FP)
9D003800  0F401855   JAL printf_lcd
9D003804  00000000   NOP
200:                                         break;
9D003808  0B400E11   J 0x9D003844
9D00380C  00000000   NOP
201:                                     case 1:
202:                                         printf_lcd("%.3f [kHz]  ", freq);
9D003810  3C029D00   LUI V0, -25344
9D003814  24446818   ADDIU A0, V0, 26648
9D003818  8FC50010   LW A1, 16(FP)
9D00381C  0F401855   JAL printf_lcd
9D003820  00000000   NOP
203:                                         break;                        
9D003824  0B400E11   J 0x9D003844
9D003828  00000000   NOP
204:                                     case 2:
205:                                         printf_lcd("%.3f [MHz]  ", freq);
9D00382C  3C029D00   LUI V0, -25344
9D003830  24446828   ADDIU A0, V0, 26664
9D003834  8FC50010   LW A1, 16(FP)
9D003838  0F401855   JAL printf_lcd
9D00383C  00000000   NOP
206:                                         break;                        
9D003840  00000000   NOP
207:                                 }
208:                                                
209:                                 LED3_W = 0;
9D003844  3C03BF88   LUI V1, -16504
9D003848  94626020   LHU V0, 24608(V1)
9D00384C  7C022944   INS V0, ZERO, 5, 1
9D003850  A4626020   SH V0, 24608(V1)
210:                             }
211:                                 
212:                             appData.state = APP_STATE_WAIT;
9D003854  24020001   ADDIU V0, ZERO, 1
9D003858  AF828030   SW V0, -32720(GP)
213:                             break;
9D00385C  0B400E1A   J 0x9D003868
9D003860  00000000   NOP
214:                         }
215:                 
216:                         /* TODO: implement your application state machine.*/
217:                         
218:                 
219:                         /* The default state should never be executed. */
220:                         default:
221:                         {
222:                             /* TODO: Handle error in application's state machine. */
223:                             break;
9D003678  0B400E1A   J 0x9D003868
9D00367C  00000000   NOP
224:                         }
225:                     }
226:                 }
9D003868  03C0E821   ADDU SP, FP, ZERO
227:                 
228:                 void APP_UpdateState(APP_STATES newState)
229:                 {
9D006B38  27BDFFF8   ADDIU SP, SP, -8
9D006B3C  AFBE0004   SW FP, 4(SP)
9D006B40  03A0F021   ADDU FP, SP, ZERO
9D006B44  AFC40008   SW A0, 8(FP)
230:                     appData.state = newState;    
9D006B48  8FC20008   LW V0, 8(FP)
9D006B4C  AF828030   SW V0, -32720(GP)
231:                 }
9D006B50  03C0E821   ADDU SP, FP, ZERO
232:                 
233:                 /*******************************************************************************
234:                  End of File
235:                  */
---  /build/bamboo/xml-data/build-dir/XC32-TBC-BLD/builddir/pic32m-source/src48x/gcc/libgcc/libgcc2.c  --
9D0023B0  00C04021   ADDU T0, A2, ZERO
9D002814  00C04021   ADDU T0, A2, ZERO
9D0023B4  00804821   ADDU T1, A0, ZERO
9D002818  00801021   ADDU V0, A0, ZERO
9D0023B8  14E0003B   BNE A3, ZERO, 0x9D0024A8
9D0023BC  00A01821   ADDU V1, A1, ZERO
9D00281C  14E0003F   BNE A3, ZERO, 0x9D00291C
9D002820  00A04821   ADDU T1, A1, ZERO
9D0023C0  00A6102B   SLTU V0, A1, A2
9D0023C4  10400048   BEQ V0, ZERO, 0x9D0024E8
9D0023C8  70C21020   CLZ V0, A2
9D002824  00A6182B   SLTU V1, A1, A2
9D002828  10600047   BEQ V1, ZERO, 0x9D002948
9D00282C  70C31820   CLZ V1, A2
9D0023CC  50400008   BEQL V0, ZERO, 0x9D0023F0
9D0023D0  00083402   SRL A2, T0, 16
9D002830  50600008   BEQL V1, ZERO, 0x9D002854
9D002834  00081C02   SRL V1, T0, 16
9D0023E0  00464004   SLLV T0, A2, V0
9D002844  00664004   SLLV T0, A2, V1
9D0023D4  00021823   SUBU V1, ZERO, V0
9D0023D8  00452804   SLLV A1, A1, V0
9D0023DC  00641806   SRLV V1, A0, V1
9D0023E4  00651825   OR V1, V1, A1
9D002838  00034823   SUBU T1, ZERO, V1
9D00283C  00652804   SLLV A1, A1, V1
9D002840  01244806   SRLV T1, A0, T1
9D002848  01254825   OR T1, T1, A1
9D0023E8  00444804   SLLV T1, A0, V0
9D00284C  00641004   SLLV V0, A0, V1
9D0023EC  00083402   SRL A2, T0, 16
9D0023F0  0066001B   DIVU V1, A2
9D0023F4  00C001F4   TEQ A2, ZERO
9D0023F8  00002010   MFHI A0
9D0023FC  00005812   MFLO T3
9D002400  310CFFFF   ANDI T4, T0, -1
9D002404  00095402   SRL T2, T1, 16
9D002408  716C5802   MUL T3, T3, T4
9D00240C  00042400   SLL A0, A0, 16
9D002410  008A5025   OR T2, A0, T2
9D002414  014B682B   SLTU T5, T2, T3
9D002418  0066001B   DIVU V1, A2
9D00241C  00C001F4   TEQ A2, ZERO
9D002420  51A00009   BEQL T5, ZERO, 0x9D002448
9D002424  014B5023   SUBU T2, T2, T3
9D002428  01485021   ADDU T2, T2, T0
9D00242C  0148182B   SLTU V1, T2, T0
9D002430  54600005   BNEL V1, ZERO, 0x9D002448
9D002434  014B5023   SUBU T2, T2, T3
9D002438  014B202B   SLTU A0, T2, T3
9D00243C  01481821   ADDU V1, T2, T0
9D002440  0064500B   MOVN T2, V1, A0
9D002444  014B5023   SUBU T2, T2, T3
9D002448  3123FFFF   ANDI V1, T1, -1
9D00244C  0146001B   DIVU T2, A2
9D002450  00C001F4   TEQ A2, ZERO
9D002454  00004810   MFHI T1
9D002458  00002012   MFLO A0
9D00245C  708C2002   MUL A0, A0, T4
9D002460  00094C00   SLL T1, T1, 16
9D002464  01234825   OR T1, T1, V1
9D002468  0124182B   SLTU V1, T1, A0
9D00246C  0146001B   DIVU T2, A2
9D002470  00C001F4   TEQ A2, ZERO
9D002474  50600009   BEQL V1, ZERO, .LBE15
9D002478  01244823   SUBU T1, T1, A0
9D00247C  01284821   ADDU T1, T1, T0
9D002480  0128182B   SLTU V1, T1, T0
9D002484  54600005   BNEL V1, ZERO, .LBE15
9D002488  01244823   SUBU T1, T1, A0
9D00248C  0124182B   SLTU V1, T1, A0
9D002490  01284021   ADDU T0, T1, T0
9D002494  0103480B   MOVN T1, T0, V1
9D002498  01244823   SUBU T1, T1, A0
9D002850  00081C02   SRL V1, T0, 16
9D002854  0123001B   DIVU T1, V1
9D002858  006001F4   TEQ V1, ZERO
9D00285C  00006010   MFHI T4
9D002860  00005812   MFLO T3
9D002864  310AFFFF   ANDI T2, T0, -1
9D002868  00022402   SRL A0, V0, 16
9D00286C  00003012   MFLO A2
9D002870  716A3802   MUL A3, T3, T2
9D002874  000C6400   SLL T4, T4, 16
9D002878  01842025   OR A0, T4, A0
9D00287C  0087602B   SLTU T4, A0, A3
9D002880  0123001B   DIVU T1, V1
9D002884  006001F4   TEQ V1, ZERO
9D002888  1180000B   BEQ T4, ZERO, 0x9D0028B8
9D00288C  00872823   SUBU A1, A0, A3
9D002890  00882021   ADDU A0, A0, T0
9D002894  0088282B   SLTU A1, A0, T0
9D002898  14A00006   BNE A1, ZERO, 0x9D0028B4
9D00289C  2566FFFF   ADDIU A2, T3, -1
9D0028A0  0087282B   SLTU A1, A0, A3
9D0028A4  10A00004   BEQ A1, ZERO, 0x9D0028B8
9D0028A8  00872823   SUBU A1, A0, A3
9D0028AC  2566FFFE   ADDIU A2, T3, -2
9D0028B0  00882021   ADDU A0, A0, T0
9D0028B4  00872823   SUBU A1, A0, A3
9D0028B8  3042FFFF   ANDI V0, V0, -1
9D0028BC  00A3001B   DIVU A1, V1
9D0028C0  006001F4   TEQ V1, ZERO
9D0028C4  00004810   MFHI T1
9D0028C8  00003812   MFLO A3
9D0028CC  00002012   MFLO A0
9D0028D0  70EA5002   MUL T2, A3, T2
9D0028D4  00094C00   SLL T1, T1, 16
9D0028D8  01221025   OR V0, T1, V0
9D0028DC  004A482B   SLTU T1, V0, T2
9D0028E0  00A3001B   DIVU A1, V1
9D0028E4  006001F4   TEQ V1, ZERO
9D0028E8  51200009   BEQL T1, ZERO, 0x9D002910
9D0028EC  00061400   SLL V0, A2, 16
9D0028F0  00481021   ADDU V0, V0, T0
9D0028F4  0048402B   SLTU T0, V0, T0
9D0028F8  15000004   BNE T0, ZERO, 0x9D00290C
9D0028FC  24E4FFFF   ADDIU A0, A3, -1
9D002900  004A502B   SLTU T2, V0, T2
9D002904  24E7FFFE   ADDIU A3, A3, -2
9D002908  00EA200B   MOVN A0, A3, T2
9D00290C  00061400   SLL V0, A2, 16
9D002910  00821025   OR V0, A0, V0
9D002914  03E00008   JR RA
9D002918  00001821   ADDU V1, ZERO, ZERO
9D0024E8  14C00006   BNE A2, ZERO, 0x9D002504
9D0024EC  71021020   CLZ V0, T0
9D002948  14C00006   BNE A2, ZERO, 0x9D002964
9D00294C  71031820   CLZ V1, T0
9D0024F0  24020001   ADDIU V0, ZERO, 1
9D0024F4  0046001B   DIVU V0, A2
9D0024F8  00C001F4   TEQ A2, ZERO
9D0024FC  00004012   MFLO T0
9D002950  24030001   ADDIU V1, ZERO, 1
9D002954  0066001B   DIVU V1, A2
9D002958  00C001F4   TEQ A2, ZERO
9D00295C  00004012   MFLO T0
9D002500  71021020   CLZ V0, T0
9D002960  71031820   CLZ V1, T0
9D002504  5440007D   BNEL V0, ZERO, 0x9D0026FC
9D002508  00484004   SLLV T0, T0, V0
9D002964  5460007B   BNEL V1, ZERO, 0x9D002B54
9D002968  00684004   SLLV T0, T0, V1
9D00250C  00A82823   SUBU A1, A1, T0
9D002510  00081C02   SRL V1, T0, 16
9D002514  3107FFFF   ANDI A3, T0, -1
9D00296C  00A82023   SUBU A0, A1, T0
9D002970  00083C02   SRL A3, T0, 16
9D002974  310BFFFF   ANDI T3, T0, -1
9D002978  24030001   ADDIU V1, ZERO, 1
9D0026FC  24090020   ADDIU T1, ZERO, 32
9D002700  01224823   SUBU T1, T1, V0
9D002B54  24020020   ADDIU V0, ZERO, 32
9D002B58  00431023   SUBU V0, V0, V1
9D002704  01255006   SRLV T2, A1, T1
9D002B5C  00454806   SRLV T1, A1, V0
9D002720  00452804   SLLV A1, A1, V0
9D002724  01244806   SRLV T1, A0, T1
9D002728  01252825   OR A1, T1, A1
9D002B78  00652804   SLLV A1, A1, V1
9D002B7C  00441006   SRLV V0, A0, V0
9D002B80  00452825   OR A1, V0, A1
9D002730  00444804   SLLV T1, A0, V0
9D002B88  00641004   SLLV V0, A0, V1
9D002708  00081C02   SRL V1, T0, 16
9D00270C  0143001B   DIVU T2, V1
9D002710  006001F4   TEQ V1, ZERO
9D002714  00003010   MFHI A2
9D002718  00005812   MFLO T3
9D00271C  3107FFFF   ANDI A3, T0, -1
9D00272C  00056402   SRL T4, A1, 16
9D002734  71675802   MUL T3, T3, A3
9D002738  00063400   SLL A2, A2, 16
9D00273C  01863025   OR A2, T4, A2
9D002740  00CB202B   SLTU A0, A2, T3
9D002744  0143001B   DIVU T2, V1
9D002748  006001F4   TEQ V1, ZERO
9D00274C  50800006   BEQL A0, ZERO, 0x9D002768
9D002750  00CB3023   SUBU A2, A2, T3
9D002754  00C83021   ADDU A2, A2, T0
9D002758  00C8202B   SLTU A0, A2, T0
9D00275C  10800024   BEQ A0, ZERO, 0x9D0027F0
9D002760  00CB502B   SLTU T2, A2, T3
9D002764  00CB3023   SUBU A2, A2, T3
9D002768  30AAFFFF   ANDI T2, A1, -1
9D00276C  00C3001B   DIVU A2, V1
9D002770  006001F4   TEQ V1, ZERO
9D002774  00002010   MFHI A0
9D002778  00002812   MFLO A1
9D00277C  70A72802   MUL A1, A1, A3
9D002780  00042400   SLL A0, A0, 16
9D002784  008A2025   OR A0, A0, T2
9D002788  0085502B   SLTU T2, A0, A1
9D00278C  00C3001B   DIVU A2, V1
9D002790  006001F4   TEQ V1, ZERO
9D002794  5140FF60   BEQL T2, ZERO, .LBB17
9D002798  00852823   SUBU A1, A0, A1
9D00279C  00882021   ADDU A0, A0, T0
9D0027A0  0088302B   SLTU A2, A0, T0
9D0027A4  54C0FF5C   BNEL A2, ZERO, .LBB17
9D0027A8  00852823   SUBU A1, A0, A1
9D0027AC  0085502B   SLTU T2, A0, A1
9D0027B0  00883021   ADDU A2, A0, T0
9D0027B4  00CA200B   MOVN A0, A2, T2
9D0027B8  0B400946   J .LBB17
9D0027BC  00852823   SUBU A1, A0, A1
9D0027F0  00C82021   ADDU A0, A2, T0
9D0027F4  0B4009D9   J 0x9D002764
9D0027F8  008A300B   MOVN A2, A0, T2
9D002B60  00083C02   SRL A3, T0, 16
9D002B64  0127001B   DIVU T1, A3
9D002B68  00E001F4   TEQ A3, ZERO
9D002B6C  00003010   MFHI A2
9D002B70  00006012   MFLO T4
9D002B74  310BFFFF   ANDI T3, T0, -1
9D002B84  00056C02   SRL T5, A1, 16
9D002B8C  00001812   MFLO V1
9D002B90  718B5002   MUL T2, T4, T3
9D002B94  00063400   SLL A2, A2, 16
9D002B98  01A63025   OR A2, T5, A2
9D002B9C  00CA202B   SLTU A0, A2, T2
9D002BA0  0127001B   DIVU T1, A3
9D002BA4  00E001F4   TEQ A3, ZERO
9D002BA8  5080000B   BEQL A0, ZERO, 0x9D002BD8
9D002BAC  00CA3023   SUBU A2, A2, T2
9D002BB0  00C83021   ADDU A2, A2, T0
9D002BB4  00C8202B   SLTU A0, A2, T0
9D002BB8  14800006   BNE A0, ZERO, 0x9D002BD4
9D002BBC  2583FFFF   ADDIU V1, T4, -1
9D002BC0  00CA202B   SLTU A0, A2, T2
9D002BC4  50800004   BEQL A0, ZERO, 0x9D002BD8
9D002BC8  00CA3023   SUBU A2, A2, T2
9D002BCC  2583FFFE   ADDIU V1, T4, -2
9D002BD0  00C83021   ADDU A2, A2, T0
9D002BD4  00CA3023   SUBU A2, A2, T2
9D002BD8  30ACFFFF   ANDI T4, A1, -1
9D002BDC  00C7001B   DIVU A2, A3
9D002BE0  00E001F4   TEQ A3, ZERO
9D002BE4  00002010   MFHI A0
9D002BE8  00005012   MFLO T2
9D002BEC  00004812   MFLO T1
9D002BF0  714B2802   MUL A1, T2, T3
9D002BF4  00042400   SLL A0, A0, 16
9D002BF8  008C2025   OR A0, A0, T4
9D002BFC  0085602B   SLTU T4, A0, A1
9D002C00  00C7001B   DIVU A2, A3
9D002C04  00E001F4   TEQ A3, ZERO
9D002C08  5180000B   BEQL T4, ZERO, 0x9D002C38
9D002C0C  00031C00   SLL V1, V1, 16
9D002C10  00882021   ADDU A0, A0, T0
9D002C14  0088302B   SLTU A2, A0, T0
9D002C18  14C00006   BNE A2, ZERO, 0x9D002C34
9D002C1C  2549FFFF   ADDIU T1, T2, -1
9D002C20  0085302B   SLTU A2, A0, A1
9D002C24  50C00004   BEQL A2, ZERO, 0x9D002C38
9D002C28  00031C00   SLL V1, V1, 16
9D002C2C  2549FFFE   ADDIU T1, T2, -2
9D002C30  00882021   ADDU A0, A0, T0
9D002C34  00031C00   SLL V1, V1, 16
9D002C38  00852023   SUBU A0, A0, A1
9D002C3C  0B400A5F   J .LBB16
9D002C40  01231825   OR V1, T1, V1
9D002518  00092402   SRL A0, T1, 16
9D00251C  00A3001B   DIVU A1, V1
9D002520  006001F4   TEQ V1, ZERO
9D002524  00005010   MFHI T2
9D002528  00003012   MFLO A2
9D00252C  70C73002   MUL A2, A2, A3
9D002530  000A5400   SLL T2, T2, 16
9D002534  01442025   OR A0, T2, A0
9D002538  0086502B   SLTU T2, A0, A2
9D00253C  00A3001B   DIVU A1, V1
9D002540  006001F4   TEQ V1, ZERO
9D002544  51400009   BEQL T2, ZERO, 0x9D00256C
9D002548  00862023   SUBU A0, A0, A2
9D00254C  00882021   ADDU A0, A0, T0
9D002550  0088282B   SLTU A1, A0, T0
9D002554  54A00005   BNEL A1, ZERO, 0x9D00256C
9D002558  00862023   SUBU A0, A0, A2
9D00255C  0086502B   SLTU T2, A0, A2
9D002560  00882821   ADDU A1, A0, T0
9D002564  00AA200B   MOVN A0, A1, T2
9D002568  00862023   SUBU A0, A0, A2
9D00256C  3126FFFF   ANDI A2, T1, -1
9D002570  0083001B   DIVU A0, V1
9D002574  006001F4   TEQ V1, ZERO
9D002578  00004810   MFHI T1
9D00257C  00002812   MFLO A1
9D002580  70A72802   MUL A1, A1, A3
9D002584  00094C00   SLL T1, T1, 16
9D002588  01264825   OR T1, T1, A2
9D00258C  0125302B   SLTU A2, T1, A1
9D002590  0083001B   DIVU A0, V1
9D002594  006001F4   TEQ V1, ZERO
9D002598  50C00009   BEQL A2, ZERO, .LBE17
9D00259C  01254823   SUBU T1, T1, A1
9D0025A0  01284821   ADDU T1, T1, T0
9D0025A4  0128182B   SLTU V1, T1, T0
9D0025A8  54600005   BNEL V1, ZERO, .LBE17
9D0025AC  01254823   SUBU T1, T1, A1
9D0025B0  0125182B   SLTU V1, T1, A1
9D0025B4  01284021   ADDU T0, T1, T0
9D0025B8  0103480B   MOVN T1, T0, V1
9D0025BC  01254823   SUBU T1, T1, A1
9D00297C  00023402   SRL A2, V0, 16
9D002980  0087001B   DIVU A0, A3
9D002984  00E001F4   TEQ A3, ZERO
9D002988  00006810   MFHI T5
9D00298C  00006012   MFLO T4
9D002990  00004812   MFLO T1
9D002994  718B5002   MUL T2, T4, T3
9D002998  000D6C00   SLL T5, T5, 16
9D00299C  01A63025   OR A2, T5, A2
9D0029A0  00CA682B   SLTU T5, A2, T2
9D0029A4  0087001B   DIVU A0, A3
9D0029A8  00E001F4   TEQ A3, ZERO
9D0029AC  11A00009   BEQ T5, ZERO, 0x9D0029D4
9D0029B0  00CA2823   SUBU A1, A2, T2
9D0029B4  00C83021   ADDU A2, A2, T0
9D0029B8  00C8202B   SLTU A0, A2, T0
9D0029BC  14800004   BNE A0, ZERO, 0x9D0029D0
9D0029C0  2589FFFF   ADDIU T1, T4, -1
9D0029C4  00CA202B   SLTU A0, A2, T2
9D0029C8  548000A6   BNEL A0, ZERO, 0x9D002C64
9D0029CC  2589FFFE   ADDIU T1, T4, -2
9D0029D0  00CA2823   SUBU A1, A2, T2
9D0029D4  3042FFFF   ANDI V0, V0, -1
9D0029D8  00A7001B   DIVU A1, A3
9D0029DC  00E001F4   TEQ A3, ZERO
9D0029E0  00005010   MFHI T2
9D0029E4  00003012   MFLO A2
9D0029E8  00002012   MFLO A0
9D0029EC  70CB5802   MUL T3, A2, T3
9D0029F0  000A5400   SLL T2, T2, 16
9D0029F4  01421025   OR V0, T2, V0
9D0029F8  004B502B   SLTU T2, V0, T3
9D0029FC  00A7001B   DIVU A1, A3
9D002A00  00E001F4   TEQ A3, ZERO
9D002A04  51400009   BEQL T2, ZERO, .LBE16
9D002A08  00091400   SLL V0, T1, 16
9D002A0C  00481021   ADDU V0, V0, T0
9D002A10  0048402B   SLTU T0, V0, T0
9D002A14  15000004   BNE T0, ZERO, 0x9D002A28
9D002A18  24C4FFFF   ADDIU A0, A2, -1
9D002A1C  004B582B   SLTU T3, V0, T3
9D002A20  24C6FFFE   ADDIU A2, A2, -2
9D002A24  00CB200B   MOVN A0, A2, T3
9D002A28  00091400   SLL V0, T1, 16
9D002A2C  03E00008   JR RA
9D002A30  00821025   OR V0, A0, V0
9D002C64  0B400A74   J 0x9D0029D0
9D00249C  00491006   SRLV V0, T1, V0
9D0025C0  00491006   SRLV V0, T1, V0
9D0024A0  03E00008   JR RA
9D0024A4  00001821   ADDU V1, ZERO, ZERO
9D0025C4  03E00008   JR RA
9D0025C8  00001821   ADDU V1, ZERO, ZERO
9D0024A8  00A7102B   SLTU V0, A1, A3
9D0024AC  14400047   BNE V0, ZERO, 0x9D0025CC
9D0024B0  70EA5020   CLZ T2, A3
9D00291C  00A7102B   SLTU V0, A1, A3
9D002920  14400044   BNE V0, ZERO, 0x9D002A34
9D002924  70E84020   CLZ T0, A3
9D002A34  00001821   ADDU V1, ZERO, ZERO
9D002A38  03E00008   JR RA
9D002A3C  00001021   ADDU V0, ZERO, ZERO
9D0025CC  00801021   ADDU V0, A0, ZERO
9D0025D0  03E00008   JR RA
9D0025D4  00A01821   ADDU V1, A1, ZERO
9D0024B4  15400048   BNE T2, ZERO, 0x9D0025D8
9D0024B8  240B0020   ADDIU T3, ZERO, 32
9D002928  55000045   BNEL T0, ZERO, 0x9D002A40
9D00292C  24020020   ADDIU V0, ZERO, 32
9D0024BC  00E5102B   SLTU V0, A3, A1
9D0024C0  14400005   BNE V0, ZERO, 0x9D0024D8
9D0024C4  00861023   SUBU V0, A0, A2
9D0024C8  0086402B   SLTU T0, A0, A2
9D0024CC  15000089   BNE T0, ZERO, 0x9D0026F4
9D0024D0  00801021   ADDU V0, A0, ZERO
9D002930  00E5282B   SLTU A1, A3, A1
9D002934  14A000C8   BNE A1, ZERO, 0x9D002C58
9D002938  0086302B   SLTU A2, A0, A2
9D00293C  38C20001   XORI V0, A2, 1
9D002940  03E00008   JR RA
9D002944  00001821   ADDU V1, ZERO, ZERO
9D002C58  00001821   ADDU V1, ZERO, ZERO
9D0024D4  00861023   SUBU V0, A0, A2
9D0024D8  00A72823   SUBU A1, A1, A3
9D0024DC  0082202B   SLTU A0, A0, V0
9D0024E0  03E00008   JR RA
9D0024E4  00A41823   SUBU V1, A1, A0
9D0025D8  016A5823   SUBU T3, T3, T2
9D002A40  00481023   SUBU V0, V0, T0
9D0025DC  01473804   SLLV A3, A3, T2
9D0025E0  01661006   SRLV V0, A2, T3
9D0025E4  00473825   OR A3, V0, A3
9D002A44  01073804   SLLV A3, A3, T0
9D002A48  00461806   SRLV V1, A2, V0
9D002A4C  00673825   OR A3, V1, A3
9D002614  01463004   SLLV A2, A2, T2
9D0025E8  01656806   SRLV T5, A1, T3
9D002A50  00455006   SRLV T2, A1, V0
9D002604  01452804   SLLV A1, A1, T2
9D002608  01641006   SRLV V0, A0, T3
9D00260C  00451025   OR V0, V0, A1
9D002A6C  01052804   SLLV A1, A1, T0
9D002A70  00441006   SRLV V0, A0, V0
9D002A74  00452825   OR A1, V0, A1
9D0025EC  00074C02   SRL T1, A3, 16
9D0025F0  01A9001B   DIVU T5, T1
9D0025F4  012001F4   TEQ T1, ZERO
9D0025F8  00006010   MFHI T4
9D0025FC  00001812   MFLO V1
9D002600  30EEFFFF   ANDI T6, A3, -1
9D002610  00022C02   SRL A1, V0, 16
9D002618  00004012   MFLO T0
9D00261C  706E7802   MUL T7, V1, T6
9D002620  000C6400   SLL T4, T4, 16
9D002624  01856025   OR T4, T4, A1
9D002628  018F282B   SLTU A1, T4, T7
9D00262C  01A9001B   DIVU T5, T1
9D002630  012001F4   TEQ T1, ZERO
9D002634  10A0000A   BEQ A1, ZERO, 0x9D002660
9D002638  01442004   SLLV A0, A0, T2
9D00263C  01876021   ADDU T4, T4, A3
9D002640  0187282B   SLTU A1, T4, A3
9D002644  14A00006   BNE A1, ZERO, 0x9D002660
9D002648  2468FFFF   ADDIU T0, V1, -1
9D00264C  018F282B   SLTU A1, T4, T7
9D002650  50A00004   BEQL A1, ZERO, 0x9D002664
9D002654  018F6023   SUBU T4, T4, T7
9D002658  2468FFFE   ADDIU T0, V1, -2
9D00265C  01876021   ADDU T4, T4, A3
9D002660  018F6023   SUBU T4, T4, T7
9D002664  3042FFFF   ANDI V0, V0, -1
9D002668  0189001B   DIVU T4, T1
9D00266C  012001F4   TEQ T1, ZERO
9D002670  00002810   MFHI A1
9D002674  00001812   MFLO V1
9D002678  00006812   MFLO T5
9D00267C  706E7002   MUL T6, V1, T6
9D002680  00052C00   SLL A1, A1, 16
9D002684  00A21025   OR V0, A1, V0
9D002688  004E282B   SLTU A1, V0, T6
9D00268C  0189001B   DIVU T4, T1
9D002690  012001F4   TEQ T1, ZERO
9D002694  50A00006   BEQL A1, ZERO, 0x9D0026B0
9D002698  00084400   SLL T0, T0, 16
9D00269C  00471021   ADDU V0, V0, A3
9D0026A0  0047282B   SLTU A1, V0, A3
9D0026A4  10A0004C   BEQ A1, ZERO, .LBE25
9D0026A8  246DFFFF   ADDIU T5, V1, -1
9D0026AC  00084400   SLL T0, T0, 16
9D0026B0  01A84025   OR T0, T5, T0
9D0026B4  004E1023   SUBU V0, V0, T6
9D0027D8  004E282B   SLTU A1, V0, T6
9D0027DC  50A0FFB4   BEQL A1, ZERO, 0x9D0026B0
9D0027E0  00084400   SLL T0, T0, 16
9D0027E4  246DFFFE   ADDIU T5, V1, -2
9D0027E8  0B4009AB   J 0x9D0026AC
9D0027EC  00471021   ADDU V0, V0, A3
9D002A54  00071C02   SRL V1, A3, 16
9D002A58  0143001B   DIVU T2, V1
9D002A5C  006001F4   TEQ V1, ZERO
9D002A60  00004810   MFHI T1
9D002A64  00006812   MFLO T5
9D002A68  30EBFFFF   ANDI T3, A3, -1
9D002A78  00057402   SRL T6, A1, 16
9D002A7C  00001012   MFLO V0
9D002A80  71AB6002   MUL T4, T5, T3
9D002A84  00094C00   SLL T1, T1, 16
9D002A88  012E4825   OR T1, T1, T6
9D002A8C  012C702B   SLTU T6, T1, T4
9D002A90  0143001B   DIVU T2, V1
9D002A94  006001F4   TEQ V1, ZERO
9D002A98  11C0000A   BEQ T6, ZERO, 0x9D002AC4
9D002A9C  01063004   SLLV A2, A2, T0
9D002AA0  01274821   ADDU T1, T1, A3
9D002AA4  0127502B   SLTU T2, T1, A3
9D002AA8  15400006   BNE T2, ZERO, 0x9D002AC4
9D002AAC  25A2FFFF   ADDIU V0, T5, -1
9D002AB0  012C502B   SLTU T2, T1, T4
9D002AB4  51400004   BEQL T2, ZERO, 0x9D002AC8
9D002AB8  012C4823   SUBU T1, T1, T4
9D002ABC  25A2FFFE   ADDIU V0, T5, -2
9D002AC0  01274821   ADDU T1, T1, A3
9D002AC4  012C4823   SUBU T1, T1, T4
9D002AC8  30A5FFFF   ANDI A1, A1, -1
9D002ACC  0123001B   DIVU T1, V1
9D002AD0  006001F4   TEQ V1, ZERO
9D002AD4  00006810   MFHI T5
9D002AD8  00006012   MFLO T4
9D002ADC  00005012   MFLO T2
9D002AE0  718B5802   MUL T3, T4, T3
9D002AE4  000D6C00   SLL T5, T5, 16
9D002AE8  01A52825   OR A1, T5, A1
9D002AEC  00AB682B   SLTU T5, A1, T3
9D002AF0  0123001B   DIVU T1, V1
9D002AF4  006001F4   TEQ V1, ZERO
9D002AF8  51A0000B   BEQL T5, ZERO, 0x9D002B28
9D002AFC  00021400   SLL V0, V0, 16
9D002B00  00A72821   ADDU A1, A1, A3
9D002B04  00A7182B   SLTU V1, A1, A3
9D002B08  14600006   BNE V1, ZERO, 0x9D002B24
9D002B0C  258AFFFF   ADDIU T2, T4, -1
9D002B10  00AB182B   SLTU V1, A1, T3
9D002B14  50600004   BEQL V1, ZERO, 0x9D002B28
9D002B18  00021400   SLL V0, V0, 16
9D002B1C  258AFFFE   ADDIU T2, T4, -2
9D002B20  00A72821   ADDU A1, A1, A3
9D002B24  00021400   SLL V0, V0, 16
9D002B28  01421025   OR V0, T2, V0
9D002B2C  00AB2823   SUBU A1, A1, T3
9D0026B8  01060019   MULTU 0, T0, A2
9D0026BC  00004810   MFHI T1
9D0026D4  00003012   MFLO A2
9D002B30  00460019   MULTU 0, V0, A2
9D002B34  00003810   MFHI A3
9D0026C0  0049182B   SLTU V1, V0, T1
9D0026C4  1460003E   BNE V1, ZERO, .LBB25
9D0026C8  00004012   MFLO T0
9D0026CC  1049004B   BEQ V0, T1, 0x9D0027FC
9D0026D0  00491823   SUBU V1, V0, T1
9D0027FC  0088182B   SLTU V1, A0, T0
9D002B38  00A7182B   SLTU V1, A1, A3
9D002B3C  14600044   BNE V1, ZERO, 0x9D002C50
9D002B40  00003012   MFLO A2
9D002B44  10A7003F   BEQ A1, A3, 0x9D002C44
9D002B48  01042004   SLLV A0, A0, T0
9D002C44  0086302B   SLTU A2, A0, A2
9D002C48  10C0FFC0   BEQ A2, ZERO, 0x9D002B4C
9D002C4C  00000000   NOP
9D002B4C  03E00008   JR RA
9D002B50  00001821   ADDU V1, ZERO, ZERO
9D002C50  0B400AD3   J 0x9D002B4C
9D002C54  2442FFFF   ADDIU V0, V0, -1
9D0027C0  01063023   SUBU A2, T0, A2
9D0027C4  01271823   SUBU V1, T1, A3
9D0027C8  0106402B   SLTU T0, T0, A2
9D0027CC  00681823   SUBU V1, V1, T0
9D0027D0  0B4009B6   J .LBB24
9D0027D4  00431823   SUBU V1, V0, V1
9D0026D8  00863023   SUBU A2, A0, A2
9D0026DC  0086202B   SLTU A0, A0, A2
9D0026E0  00641823   SUBU V1, V1, A0
9D0026E4  01631004   SLLV V0, V1, T3
9D0026E8  01463006   SRLV A2, A2, T2
9D0026EC  00461025   OR V0, V0, A2
9D0026F0  01431806   SRLV V1, V1, T2
9D0026F4  03E00008   JR RA
9D0026F8  00000000   NOP
9D002C5C  03E00008   JR RA
9D002C60  24020001   ADDIU V0, ZERO, 1
9D006438  27BDFFE0   ADDIU SP, SP, -32
9D00643C  AFBF001C   SW RA, 28(SP)
9D006440  AFB00018   SW S0, 24(SP)
9D006444  00808021   ADDU S0, A0, ZERO
9D006448  0F401A68   JAL __floatunsidf
9D00644C  00A02021   ADDU A0, A1, ZERO
9D006450  3C049D00   LUI A0, -25344
9D006454  8C866F98   LW A2, 28568(A0)
9D006458  8C876F9C   LW A3, 28572(A0)
9D00645C  00402021   ADDU A0, V0, ZERO
9D006460  0F400C27   JAL __muldf3
9D006464  00602821   ADDU A1, V1, ZERO
9D006468  02002021   ADDU A0, S0, ZERO
9D00646C  AFA20010   SW V0, 16(SP)
9D006470  0F401A68   JAL __floatunsidf
9D006474  AFA30014   SW V1, 20(SP)
9D006478  00402021   ADDU A0, V0, ZERO
9D00647C  00602821   ADDU A1, V1, ZERO
9D006480  8FA60010   LW A2, 16(SP)
9D006484  0F400B1D   JAL dpadd
9D006488  8FA70014   LW A3, 20(SP)
9D00648C  8FBF001C   LW RA, 28(SP)
---  /build/bamboo/xml-data/build-dir/XC32-TBC-BLD/builddir/pic32m-source/src48x/gcc/libgcc/floatunsisf.c
9D0067AC  27BDFFE8   ADDIU SP, SP, -24
9D0067B0  AFBF0014   SW RA, 20(SP)
9D0067B4  04800006   BLTZ A0, 0x9D0067D0
9D0067B8  00801021   ADDU V0, A0, ZERO
9D0067D0  00042042   SRL A0, A0, 1
9D0067D4  30420001   ANDI V0, V0, 1
9D0067D8  0F401957   JAL sitofp
9D0067DC  00822025   OR A0, A0, V0
9D0067E0  00402021   ADDU A0, V0, ZERO
9D0067E4  0F400CF4   JAL fpadd
9D0067E8  00402821   ADDU A1, V0, ZERO
9D0067BC  0F401957   JAL sitofp
9D0067C0  00000000   NOP
9D0067C4  8FBF0014   LW RA, 20(SP)
9D0067C8  03E00008   JR RA
9D0067CC  27BD0018   ADDIU SP, SP, 24
9D0067EC  8FBF0014   LW RA, 20(SP)
---  /build/bamboo/xml-data/build-dir/XC32-TBC-BLD/builddir/pic32m-source/src48x/gcc/libgcc/floatunsidf.c
9D0069A0  27BDFFE8   ADDIU SP, SP, -24
9D0069A4  AFBF0014   SW RA, 20(SP)
9D0069A8  AFB00010   SW S0, 16(SP)
9D0069AC  0F40181B   JAL litodp
9D0069B0  00808021   ADDU S0, A0, ZERO
9D0069B4  06010008   BGEZ S0, 0x9D0069D8
9D0069B8  8FBF0014   LW RA, 20(SP)
9D0069BC  3C049D00   LUI A0, -25344
9D0069C0  8C866FA0   LW A2, 28576(A0)
9D0069C4  8C876FA4   LW A3, 28580(A0)
9D0069C8  00402021   ADDU A0, V0, ZERO
9D0069CC  0F400B1D   JAL dpadd
9D0069D0  00602821   ADDU A1, V1, ZERO
9D0069D4  8FBF0014   LW RA, 20(SP)
